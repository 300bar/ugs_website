{
    "docs": [
        {
            "location": "/", 
            "text": "Universal Gcode Sender\n\n\n\n\n\n\nA full featured gcode platform used for interfacing with advanced CNC controllers like \nGRBL\n\nand \nTinyG\n.\nUniversal Gcode Sender is a self-contained Java application which includes all external dependencies,\nthat means if you have the Java Runtime Environment setup UGS provides the rest.\n\n\n\n\n  \n\n  \n\n  \n\n  \n\n\n\n\n\n\n\n\nDownloads\n\n\nSee the \nDownloads page\n.\n\n\n\n\nFeatures\n\n\n\n\nCross platform, tested on Windows, OSX, Linux, and Raspberry Pi.\n\n\nExecutable All-In-One JAR file - if you have java there is nothing to install. The JAR file includes native dependencies for all supported operating systems.\n\n\n3D Gcode Visualizer with color coded line segments and real time tool position feedback.\n\n\nDuration estimates.\n\n\nOver 3000 lines of unit test code, and another 1000 lines of comments documenting the tests.\n\n\nConfiguratble gcode optimization:\n\n\nRemove comments\n\n\nTruncate decimal precision to configurable amount\n\n\nConvert arcs (G2/G3) to line segments\n\n\nRemove whitespace\n\n\n\n\n\n\n\n\n\n\nScreenshots", 
            "title": "Home"
        }, 
        {
            "location": "/#universal-gcode-sender", 
            "text": "A full featured gcode platform used for interfacing with advanced CNC controllers like  GRBL \nand  TinyG .\nUniversal Gcode Sender is a self-contained Java application which includes all external dependencies,\nthat means if you have the Java Runtime Environment setup UGS provides the rest.", 
            "title": "Universal Gcode Sender"
        }, 
        {
            "location": "/#downloads", 
            "text": "See the  Downloads page .", 
            "title": "Downloads"
        }, 
        {
            "location": "/#features", 
            "text": "Cross platform, tested on Windows, OSX, Linux, and Raspberry Pi.  Executable All-In-One JAR file - if you have java there is nothing to install. The JAR file includes native dependencies for all supported operating systems.  3D Gcode Visualizer with color coded line segments and real time tool position feedback.  Duration estimates.  Over 3000 lines of unit test code, and another 1000 lines of comments documenting the tests.  Configuratble gcode optimization:  Remove comments  Truncate decimal precision to configurable amount  Convert arcs (G2/G3) to line segments  Remove whitespace", 
            "title": "Features"
        }, 
        {
            "location": "/#screenshots", 
            "text": "", 
            "title": "Screenshots"
        }, 
        {
            "location": "/download/", 
            "text": "Releases\n\n\n\n\n\n\n\n\nVersion\n\n\nJava Version Required\n\n\n\n\n\n\n\n\n\n\n1.0.9\n\n\n7+\n\n\n\n\n\n\n1.0.8\n\n\n7+\n\n\n\n\n\n\n1.0.7\n\n\n7+\n\n\n\n\n\n\n1.0.6\n\n\n6+\n\n\n\n\n\n\n\n\nOlder releases can be found \non github\n\n\n\n\n\n\nNightly Builds\n\n\nThese builds are generated automatically and contain all changes since the last release.\nUGS has a comprehensive set of automated tests and the build will not pass if any of the tests are failing.\n\n\nThe nightly builds now require Java 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClassic GUI\n\n\nThe classic UGS GUI.\n\n\n\n\n\n\nUGS Platform\n\n\nThe next generation platform-based GUI utilizing the UGS API.", 
            "title": "Download"
        }, 
        {
            "location": "/download/#releases", 
            "text": "Version  Java Version Required      1.0.9  7+    1.0.8  7+    1.0.7  7+    1.0.6  6+     Older releases can be found  on github", 
            "title": "Releases"
        }, 
        {
            "location": "/download/#nightly-builds", 
            "text": "These builds are generated automatically and contain all changes since the last release.\nUGS has a comprehensive set of automated tests and the build will not pass if any of the tests are failing.  The nightly builds now require Java 8            Classic GUI  The classic UGS GUI.    UGS Platform  The next generation platform-based GUI utilizing the UGS API.", 
            "title": "Nightly Builds"
        }, 
        {
            "location": "/guide/platform/", 
            "text": "Platform", 
            "title": "UGS Platform"
        }, 
        {
            "location": "/guide/platform/#platform", 
            "text": "", 
            "title": "Platform"
        }, 
        {
            "location": "/guide/user/", 
            "text": "Work in progress", 
            "title": "Setup"
        }, 
        {
            "location": "/guide/user/#work-in-progress", 
            "text": "", 
            "title": "Work in progress"
        }, 
        {
            "location": "/dev/getting_started/", 
            "text": "Getting started", 
            "title": "Getting Started"
        }, 
        {
            "location": "/dev/getting_started/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/dev/development/", 
            "text": "Development", 
            "title": "Backend"
        }, 
        {
            "location": "/dev/development/#development", 
            "text": "", 
            "title": "Development"
        }, 
        {
            "location": "/dev/plugin/", 
            "text": "Plugin development\n\n\nThe UGS Platform is built ontop of the NetBeans Platform. This gives us powerful\ntools to work with, including a robust plugin system. The heart of the UGS\nPlatform is a module which wraps and exposes the Universal Gcode Sender JAR\nfile - the same jar you could execute to run the Classic GUI! Other than using\nthe UGSLib module, developing a plugin for the UGS Platform is exactly the same\nas developing any other NetBeans Platform plugin. And there is lots of great\ndocumentation for that! Here is the \nNetBeans Platform Plugin Quick Start\n\nguide.\n\n\nWorkflow Plugin Tutorial\n\n\nIn this tutorial we're going to build a window to help manage jobs that use\nmultiple tools which are split into multiple tools. The rough design idea will\nhave a central table with four columns containing:\n\n File name\n\n Tool name (editable)\n* Finished flag\n\n\nThere will be a pair of buttons to add and remove files from the table, and\nwill also hook up a lifecycle event listener for other file open events.\n\n\nThere will be another pair of buttons to move rows around in the table, so that\nif files were added out of order the order can be corrected.\n\n\nHere is a sketch of what we're building:\n\n\n\nCreate and configure project\n\n\nUniversal Gcode Sender is developed with NetBeans, and plugins are no exception.\nOnce you've cloned the Universal Gcode Sender project you should be able to open\nthe UGSPlatform folder with NetBeans and it will discover a project that you can open.\nTo start building your module expand the UGSPlatform section, right-click the\nmodules directory and select \nAdd New...\n.\n\n\n\n\nThis will open up a wizard where you name the module, and declare the source\npath. For this example the module is named WorkflowModuleTutorial and the source\npath is com.willwinder.ugs.nbp.workflowmoduletutorial which is the convention\nused in the core modules.\n\n\n\n\nAdd UGS dependencies\n\n\nYour module should now be listed in the Modules section. If it doesn't you may\nneed to restart NetBeans. Before we dive into the code there are a couple helper\nclasses to import which will give you full access to the UGS API. Double click\nyour module from the Modules section to open the code, then right-click the top\nlevel item which appeared and select the properties menu.\n\n\nSelect \nAdd Dependency...\n, here you should search for \nUGSLib\n and\n\nCentralLookup\n then add them to your plugin.\n\n\n\n\nCreate window class\n\n\nNow we're ready to build the module. In this tutorial we're building a window\nto manage a multi-job workflow, so we'll start by adding a window to customize.\n\n\n\n\nOpen the new module and right click the new package, in the context menu go to\n\nNew\n -\n \nWindow...\n. To bring up the new window wizard.\n\n\nIn the first screen of the wizard choose the default location your window\nwill appear. Custom locations have been designed for UGS Platform, the largest\nis named \nvisualizer\n because it is the Visualizer's default location. We'll\nuse this location for our plugin.  This means that when our plugin opens it will\nbe tabbed with the Visualizer module.\n\n\nClick next and choose a class name for your module, for this tutorial I'm\ngoing to call it \nWorkflowModuleTutorial\n.\n\n\n\n\n\n\nBuild the GUI\n\n\nThe NetBeans GUI builder makes it easy to make a custom user interface without\nwriting a single line of code (which is the main reason UGS uses NetBeans!).\nUsing the GUI builder we'll add some buttons and a table. This step can be as\nelaborate as you want. If you're a seasoned swing developer and prefer not to\nuse the magic GUI builder, no worries, you can create the UI programatically as\nwell - but that is a different tutorial.\n\n\n\n\nTake a look at the screenshot below. The \n[TopComponent] - Navigator - Editor\n\n  window shows all the objects that have been added with the GUI builder.\n\n\nThere are four JButtons, a JTable nested inside a JScrollPane and a JPanel\n  which I used to make alignment a little easier (The GUI Builder is powerful,\n  but it can also be a bit quirky).\n\n\nPutting the JTable inside a JScrollPane makes it so that if too many items\n  get added to the table it will scroll rather than dissapear off the bottom.\n\n\nNote:\n The name given to these components will be used in the code, so\n  be sure to use the names shown in the screenshot.\n\n\n\n\n\n\nThe JTable is going to be the trickiest part of build the GUI. To configure the\ntable right-click the JTable object from the component navigator and select\n\nTable Contents...\n. Here you can add our 3 columns and specify that the data\ntypes. You can also specify which columns are editable, in this example we want\nthe user to be able to type in what type of tool should be used.\n\n\n\n\nAutogenerated code\n\n\nBefore writing any code, lets take a look at what has already been automatically\ngenerated for us.\n\n\n\n\n\n\nJust above the class there are a number of annotations. These are used by\n   the NetBeans platform, most of them were setup according to how you filled\n   in the Wizards earlier. They can also configure things like keyboard\n   shortcuts, and where things are put in the dropdown menus.\n\n\n\n\n\n\nWithin the class there are several grayed out sections. This is code\n   generated by NetBeans which the IDE prevents you from modifying outside the\n   GUI builder or in some cases component properties. For example if you wanted\n   to use a custom JTable, you would configure the table in the GUI builder by\n   adding a custom constructor.\n\n\n\n\n\n\nAt the end of the file is \ncomponentOpened\n and \ncomponentClosed\n, these are\n   lifecycle events that are called when the window has been opened or closed.\n\n\n\n\n\n\nAlso at the end of the file is \nwriteProperties\n and \nreadProperties\n, these\n   are used to save the window state between runs.\n\n\n\n\n\n\nAnnotated code\n\n\nThis is the longest section because it will explain every line of code added to\nthe \nWorkflowModuleTutorial\n class. The most complicated code deals with Swing\ncomponent manipulation, with just a smattering of UGS lifecycle events to push\nthings along.\n\n\nClass signature\n\n\n\n\nFirst there are a few class state object we'll need and two Listeners we'll\n  be implementing.\n\n\n\n\n/**\n * ControlStateListener - this is how a plugin can listen to UGS lifecycle events.\n * ListSelectionListener - listen for table selections.\n */\npublic final class WorkflowWindowTutorialTopComponent\n        extends TopComponent\n        implements ControlStateListener, ListSelectionListener {\n\n    // These are the UGS backend objects for interacting with the backend.\n    private final Settings settings;\n    private final BackendAPI backend;\n\n    // This is used to identify when a stream has completed.\n    private boolean wasSending;\n\n    // This is used in most methods, so cache it here.\n    DefaultTableModel model;\n\n\n\n\nConstructor\n\n\n\n\nIn the constructor we register the class with the UGS backend and also set\n  the class as a listener to table selection events.\n\n\n\n\n    public WorkflowWindowTopComponent() {\n        initComponents();\n        setName(Bundle.CTL_WorkflowWindowTopComponent());\n        setToolTipText(Bundle.HINT_WorkflowWindowTopComponent());\n\n        // This is how to access the UGS backend and register the listener.\n        // CentralLookup is used to get singleton instances of the UGS\n        // Settings and BackendAPI objects.\n        settings = CentralLookup.getDefault().lookup(Settings.class);\n        backend = CentralLookup.getDefault().lookup(BackendAPI.class);\n        backend.addControlStateListener(this);\n\n        // Allow contiguous ranges of selections and register a listener.\n        this.fileTable.setSelectionMode(\n            ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n        ListSelectionModel cellSelectionModel =\n            this.fileTable.getSelectionModel();\n        cellSelectionModel.addListSelectionListener(this);\n\n        // Cache the model object.\n        model = (DefaultTableModel)this.fileTable.getModel();\n    }\n\n\n\n\nUGS Event Listener\n\n\n\n\nThis is the event sent from the UGS Backend, when a file is loaded or the\n  state changes a notification will be sent.\n\n\nIf the state switches from \nCOMM_SENDING\n to \nCOMM_IDLE\n we'll run a\n  \ncompleteFile\n method.\n\n\nIf a file is loaded, we add it to the table.\n\n\n\n\n    @Override\n    public void ControlStateEvent(ControlStateEvent cse) {\n        switch (cse.getEventType()) {\n            case STATE_CHANGED:\n                if (wasSending \n cse.getState() == ControlState.COMM_IDLE)\n                   this.completeFile(backend.getGcodeFile());\n                wasSending = backend.isSending();\n                break;\n            case FILE_CHANGED:\n                this.addFileToWorkflow(backend.getGcodeFile());\n                break;\n            default:\n                throw new AssertionError(cse.getEventType().name());\n        }\n    }\n\n\n\n\nFile Complete Handler\n\n\n\n\nWhen a command is complete we'll update the JTable, select the next file that\n  needs to be sent and popup a notification informing the user what they should\n  do next. The selection event will be sent and handled in the selection\n  handler.\n\n\n\n\n    public void completeFile(File gcodeFile) {\n        if (gcodeFile == null) return;\n\n        // Make sure the file is loaded in the table.\n        int fileIndex = findFileIndex(gcodeFile);\n        if (fileIndex \n 0) return;\n\n        // Mark that it has been completed.\n        model.setValueAt(true, fileIndex, 2);\n\n        fileIndex++;\n        String message;\n\n        // Make sure there is another command left.\n        if (fileIndex \n fileTable.getRowCount()) {\n            String nextTool = (String) model.getValueAt(fileIndex, 1);\n            String messageTemplate =\n                   \nFinished sending '%s'.\\n\n\n                 + \nThe next file uses tool '%s'\\n\n\n                 + \nLoad tool and move machine to its zero location\\n\n\n                 + \nand click send to continue this workflow.\n;\n            message = String.format(\n                messageTemplate, gcodeFile.getName(), nextTool);\n\n            // Select the next row, this will trigger a selection event.\n            fileTable.setRowSelectionInterval(fileIndex, fileIndex);\n\n        // Use a different message if we're finished.\n        } else {\n            message = \nFinished sending the last file!\n;\n        }\n\n        // Display a notification.\n        java.awt.EventQueue.invokeLater(() -\n {\n            JOptionPane.showMessageDialog(new JFrame(), message, \n                    \nWorkflow Event\n, JOptionPane.PLAIN_MESSAGE);\n        });\n    }\n\n\n\n\nJTable Selection Listener\n\n\n\n\nThis is the selection listener, when a file is selected load it in the backend.\n\n\n\n\n    @Override\n    public void valueChanged(ListSelectionEvent e) {\n        int[] selectedRow = fileTable.getSelectedRows();\n        // Only load files when there is a single selection.\n        if (selectedRow.length == 1) {\n            // Pull the file out of the table and set it in the backend.\n            String file = (String) model.getValueAt(selectedRow[0], 0);\n            try {\n                backend.setGcodeFile(new File(file));\n            } catch (Exception ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        }\n    }\n\n\n\n\nJTable Helper\n\n\n\n\nHelper method to add a file to the JTable, first making sure that it isn't\n  already in the table.\n\n\n\n\n    public void addFileToWorkflow(File gcodeFile) {\n        if (gcodeFile == null) {\n            return;\n        }\n\n        int fileIndex = findFileIndex(gcodeFile);\n        // Don't re-add a file.\n        if (fileIndex \n= 0) {\n            return;\n        }\n\n        model.addRow(new Object[]{\n                gcodeFile.getAbsolutePath(),\n                \ndefault\n,\n                false\n            });\n\n        // Fire off the selection event to load the file.\n        int lastRow = fileTable.getRowCount() - 1;\n        fileTable.setRowSelectionInterval(lastRow, lastRow);\n    }\n\n\n\n\nAdd/Remove Button Action Handlers\n\n\n\n\nNow we implement the button event methods. They are generated by double\n  clicking the buttons in the GUI Builder. This generates the swing code that\n  attaches the \nActionPerformed\n events to the button click callbacks.\n\n\naddButtonActionPerformed\n simply displays a file chooser (using some UGS\n  library built ins) and calls the \naddFileToWorkflow\n method defined earlier.\n\n\nremoveButtonActoinPerformed\n is even simpler, it uses standard JTable\n  functionality to remove any selected rows. The only thing clever here is that\n  rows are removed starting from the end to avoid having the index of later\n  selections change while deleting rows one at a time.\n\n\n\n\n    private void addButtonActionPerformed(ActionEvent evt) {                                          \n        // Open a file chooser pointing at the last opened directory.\n        JFileChooser fileChooser = GcodeFileTypeFilter.getGcodeFileChooser(\n            settings.getLastOpenedFilename());\n\n        int returnVal = fileChooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File gcodeFile = fileChooser.getSelectedFile();\n\n            // Save the new directory!\n            settings.setLastOpenedFilename(gcodeFile.getParent());\n\n            addFileToWorkflow(gcodeFile);\n        }  \n    }                                         \n\n    private void removeButtonActionPerformed(ActionEvent evt) {                                             \n        int[] selectedRows = fileTable.getSelectedRows();\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n        for (int i = selectedRows.length - 1; i \n= 0; i--) {\n            int row = selectedRows[i]\n            this.model.removeRow(row);\n            this.model.fireTableRowsDeleted(row, row);\n        }\n    }                                            \n\n\n\n\nUp / Down Button Action Handlers\n\n\n\n\nThe up and down action buttons are pure java code. They don't do anything\n  you wouldn't do with any other Swing application. The code here deals strictly\n  with moving selections around. Although a little tricky, and not totally\n  relevant to UGS, they are included because the feature wouldn't be complete\n  without them.\n\n\n\n\n    private void upButtonActionPerformed(ActionEvent evt) {                                         \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[0] == 0) return;\n\n        for (int i = 0; i \n selectedRows.length; i++) {\n            selectedRows[i] = this.moveRow(selectedRows[i], -1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    }                                        \n\n    private void downButtonActionPerformed(ActionEvent evt) {                                           \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[selectedRows.length-1]\n                == fileTable.getRowCount()) return;\n\n        for (int i = selectedRows.length - 1; i \n= 0; i--) {\n            selectedRows[i] = this.moveRow(selectedRows[i], 1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    } \n\n\n\n\nNetBeans Platform Component Lifecycle Code\n\n\n\n\nOf the automatically generated methods, \ncomponentOpened\n is the only one\n  which needed some custom code. In case the component had been closed earlier\n  or wasn't loaded until after a file stream started, grab the \nwasSending\n\n  state and save it for later.\n\n\n\n\n    @Override\n    public void componentOpened() {\n        this.wasSending = backend.isSending();\n    }\n\n    @Override\n    public void componentClosed() {\n        // No special close handling.\n    }\n\n    void writeProperties(java.util.Properties p) {\n        // better to version settings since initial version as advocated at\n        // http://wiki.apidesign.org/wiki/PropertyFiles\n        p.setProperty(\nversion\n, \n1.0\n);\n\n        // We could save the loaded files here\n    }\n\n    void readProperties(java.util.Properties p) {\n        String version = p.getProperty(\nversion\n);\n\n        // We could load previously loaded files here\n    }\n\n\n\n\nHelper Methods\n\n\n\n\nFinally, here are the helper methods used above.\n\n\n\n\n    /**\n     * Look for the provided file in the file table.\n     */\n    private int findFileIndex(File gcodeFile) {\n        if (gcodeFile == null) return -1;\n\n        for (int i = 0; i \n model.getRowCount(); i++) {\n            String file = (String) model.getValueAt(i, 0);\n            if (file != null \n gcodeFile.getAbsolutePath().equals(file)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Move a given row by some offset. If the offset would move the row outside\n     * of the current table size, the row is not moved.\n     */\n    private int moveRow(int row, int offset) {\n        int dest = row + offset;\n        if (dest \n 0 || dest \n= model.getRowCount()) {\n            return row;\n        }\n\n        model.moveRow(row, row, dest);\n        return dest;\n    }\n\n\n\n\nConclusion\n\n\nHere is a quick screencast of what this plugin does for us. In the GUI builder I swapped in some up/down arrows compared to the tutorial.", 
            "title": "Plugin"
        }, 
        {
            "location": "/dev/plugin/#plugin-development", 
            "text": "The UGS Platform is built ontop of the NetBeans Platform. This gives us powerful\ntools to work with, including a robust plugin system. The heart of the UGS\nPlatform is a module which wraps and exposes the Universal Gcode Sender JAR\nfile - the same jar you could execute to run the Classic GUI! Other than using\nthe UGSLib module, developing a plugin for the UGS Platform is exactly the same\nas developing any other NetBeans Platform plugin. And there is lots of great\ndocumentation for that! Here is the  NetBeans Platform Plugin Quick Start \nguide.", 
            "title": "Plugin development"
        }, 
        {
            "location": "/dev/plugin/#workflow-plugin-tutorial", 
            "text": "In this tutorial we're going to build a window to help manage jobs that use\nmultiple tools which are split into multiple tools. The rough design idea will\nhave a central table with four columns containing:  File name  Tool name (editable)\n* Finished flag  There will be a pair of buttons to add and remove files from the table, and\nwill also hook up a lifecycle event listener for other file open events.  There will be another pair of buttons to move rows around in the table, so that\nif files were added out of order the order can be corrected.  Here is a sketch of what we're building:", 
            "title": "Workflow Plugin Tutorial"
        }, 
        {
            "location": "/dev/plugin/#create-and-configure-project", 
            "text": "Universal Gcode Sender is developed with NetBeans, and plugins are no exception.\nOnce you've cloned the Universal Gcode Sender project you should be able to open\nthe UGSPlatform folder with NetBeans and it will discover a project that you can open.\nTo start building your module expand the UGSPlatform section, right-click the\nmodules directory and select  Add New... .   This will open up a wizard where you name the module, and declare the source\npath. For this example the module is named WorkflowModuleTutorial and the source\npath is com.willwinder.ugs.nbp.workflowmoduletutorial which is the convention\nused in the core modules.", 
            "title": "Create and configure project"
        }, 
        {
            "location": "/dev/plugin/#add-ugs-dependencies", 
            "text": "Your module should now be listed in the Modules section. If it doesn't you may\nneed to restart NetBeans. Before we dive into the code there are a couple helper\nclasses to import which will give you full access to the UGS API. Double click\nyour module from the Modules section to open the code, then right-click the top\nlevel item which appeared and select the properties menu.  Select  Add Dependency... , here you should search for  UGSLib  and CentralLookup  then add them to your plugin.", 
            "title": "Add UGS dependencies"
        }, 
        {
            "location": "/dev/plugin/#create-window-class", 
            "text": "Now we're ready to build the module. In this tutorial we're building a window\nto manage a multi-job workflow, so we'll start by adding a window to customize.   Open the new module and right click the new package, in the context menu go to New  -   Window... . To bring up the new window wizard.  In the first screen of the wizard choose the default location your window\nwill appear. Custom locations have been designed for UGS Platform, the largest\nis named  visualizer  because it is the Visualizer's default location. We'll\nuse this location for our plugin.  This means that when our plugin opens it will\nbe tabbed with the Visualizer module.  Click next and choose a class name for your module, for this tutorial I'm\ngoing to call it  WorkflowModuleTutorial .", 
            "title": "Create window class"
        }, 
        {
            "location": "/dev/plugin/#build-the-gui", 
            "text": "The NetBeans GUI builder makes it easy to make a custom user interface without\nwriting a single line of code (which is the main reason UGS uses NetBeans!).\nUsing the GUI builder we'll add some buttons and a table. This step can be as\nelaborate as you want. If you're a seasoned swing developer and prefer not to\nuse the magic GUI builder, no worries, you can create the UI programatically as\nwell - but that is a different tutorial.   Take a look at the screenshot below. The  [TopComponent] - Navigator - Editor \n  window shows all the objects that have been added with the GUI builder.  There are four JButtons, a JTable nested inside a JScrollPane and a JPanel\n  which I used to make alignment a little easier (The GUI Builder is powerful,\n  but it can also be a bit quirky).  Putting the JTable inside a JScrollPane makes it so that if too many items\n  get added to the table it will scroll rather than dissapear off the bottom.  Note:  The name given to these components will be used in the code, so\n  be sure to use the names shown in the screenshot.    The JTable is going to be the trickiest part of build the GUI. To configure the\ntable right-click the JTable object from the component navigator and select Table Contents... . Here you can add our 3 columns and specify that the data\ntypes. You can also specify which columns are editable, in this example we want\nthe user to be able to type in what type of tool should be used.", 
            "title": "Build the GUI"
        }, 
        {
            "location": "/dev/plugin/#autogenerated-code", 
            "text": "Before writing any code, lets take a look at what has already been automatically\ngenerated for us.    Just above the class there are a number of annotations. These are used by\n   the NetBeans platform, most of them were setup according to how you filled\n   in the Wizards earlier. They can also configure things like keyboard\n   shortcuts, and where things are put in the dropdown menus.    Within the class there are several grayed out sections. This is code\n   generated by NetBeans which the IDE prevents you from modifying outside the\n   GUI builder or in some cases component properties. For example if you wanted\n   to use a custom JTable, you would configure the table in the GUI builder by\n   adding a custom constructor.    At the end of the file is  componentOpened  and  componentClosed , these are\n   lifecycle events that are called when the window has been opened or closed.    Also at the end of the file is  writeProperties  and  readProperties , these\n   are used to save the window state between runs.", 
            "title": "Autogenerated code"
        }, 
        {
            "location": "/dev/plugin/#annotated-code", 
            "text": "This is the longest section because it will explain every line of code added to\nthe  WorkflowModuleTutorial  class. The most complicated code deals with Swing\ncomponent manipulation, with just a smattering of UGS lifecycle events to push\nthings along.  Class signature   First there are a few class state object we'll need and two Listeners we'll\n  be implementing.   /**\n * ControlStateListener - this is how a plugin can listen to UGS lifecycle events.\n * ListSelectionListener - listen for table selections.\n */\npublic final class WorkflowWindowTutorialTopComponent\n        extends TopComponent\n        implements ControlStateListener, ListSelectionListener {\n\n    // These are the UGS backend objects for interacting with the backend.\n    private final Settings settings;\n    private final BackendAPI backend;\n\n    // This is used to identify when a stream has completed.\n    private boolean wasSending;\n\n    // This is used in most methods, so cache it here.\n    DefaultTableModel model;  Constructor   In the constructor we register the class with the UGS backend and also set\n  the class as a listener to table selection events.       public WorkflowWindowTopComponent() {\n        initComponents();\n        setName(Bundle.CTL_WorkflowWindowTopComponent());\n        setToolTipText(Bundle.HINT_WorkflowWindowTopComponent());\n\n        // This is how to access the UGS backend and register the listener.\n        // CentralLookup is used to get singleton instances of the UGS\n        // Settings and BackendAPI objects.\n        settings = CentralLookup.getDefault().lookup(Settings.class);\n        backend = CentralLookup.getDefault().lookup(BackendAPI.class);\n        backend.addControlStateListener(this);\n\n        // Allow contiguous ranges of selections and register a listener.\n        this.fileTable.setSelectionMode(\n            ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n        ListSelectionModel cellSelectionModel =\n            this.fileTable.getSelectionModel();\n        cellSelectionModel.addListSelectionListener(this);\n\n        // Cache the model object.\n        model = (DefaultTableModel)this.fileTable.getModel();\n    }  UGS Event Listener   This is the event sent from the UGS Backend, when a file is loaded or the\n  state changes a notification will be sent.  If the state switches from  COMM_SENDING  to  COMM_IDLE  we'll run a\n   completeFile  method.  If a file is loaded, we add it to the table.       @Override\n    public void ControlStateEvent(ControlStateEvent cse) {\n        switch (cse.getEventType()) {\n            case STATE_CHANGED:\n                if (wasSending   cse.getState() == ControlState.COMM_IDLE)\n                   this.completeFile(backend.getGcodeFile());\n                wasSending = backend.isSending();\n                break;\n            case FILE_CHANGED:\n                this.addFileToWorkflow(backend.getGcodeFile());\n                break;\n            default:\n                throw new AssertionError(cse.getEventType().name());\n        }\n    }  File Complete Handler   When a command is complete we'll update the JTable, select the next file that\n  needs to be sent and popup a notification informing the user what they should\n  do next. The selection event will be sent and handled in the selection\n  handler.       public void completeFile(File gcodeFile) {\n        if (gcodeFile == null) return;\n\n        // Make sure the file is loaded in the table.\n        int fileIndex = findFileIndex(gcodeFile);\n        if (fileIndex   0) return;\n\n        // Mark that it has been completed.\n        model.setValueAt(true, fileIndex, 2);\n\n        fileIndex++;\n        String message;\n\n        // Make sure there is another command left.\n        if (fileIndex   fileTable.getRowCount()) {\n            String nextTool = (String) model.getValueAt(fileIndex, 1);\n            String messageTemplate =\n                    Finished sending '%s'.\\n \n                 +  The next file uses tool '%s'\\n \n                 +  Load tool and move machine to its zero location\\n \n                 +  and click send to continue this workflow. ;\n            message = String.format(\n                messageTemplate, gcodeFile.getName(), nextTool);\n\n            // Select the next row, this will trigger a selection event.\n            fileTable.setRowSelectionInterval(fileIndex, fileIndex);\n\n        // Use a different message if we're finished.\n        } else {\n            message =  Finished sending the last file! ;\n        }\n\n        // Display a notification.\n        java.awt.EventQueue.invokeLater(() -  {\n            JOptionPane.showMessageDialog(new JFrame(), message, \n                     Workflow Event , JOptionPane.PLAIN_MESSAGE);\n        });\n    }  JTable Selection Listener   This is the selection listener, when a file is selected load it in the backend.       @Override\n    public void valueChanged(ListSelectionEvent e) {\n        int[] selectedRow = fileTable.getSelectedRows();\n        // Only load files when there is a single selection.\n        if (selectedRow.length == 1) {\n            // Pull the file out of the table and set it in the backend.\n            String file = (String) model.getValueAt(selectedRow[0], 0);\n            try {\n                backend.setGcodeFile(new File(file));\n            } catch (Exception ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        }\n    }  JTable Helper   Helper method to add a file to the JTable, first making sure that it isn't\n  already in the table.       public void addFileToWorkflow(File gcodeFile) {\n        if (gcodeFile == null) {\n            return;\n        }\n\n        int fileIndex = findFileIndex(gcodeFile);\n        // Don't re-add a file.\n        if (fileIndex  = 0) {\n            return;\n        }\n\n        model.addRow(new Object[]{\n                gcodeFile.getAbsolutePath(),\n                 default ,\n                false\n            });\n\n        // Fire off the selection event to load the file.\n        int lastRow = fileTable.getRowCount() - 1;\n        fileTable.setRowSelectionInterval(lastRow, lastRow);\n    }  Add/Remove Button Action Handlers   Now we implement the button event methods. They are generated by double\n  clicking the buttons in the GUI Builder. This generates the swing code that\n  attaches the  ActionPerformed  events to the button click callbacks.  addButtonActionPerformed  simply displays a file chooser (using some UGS\n  library built ins) and calls the  addFileToWorkflow  method defined earlier.  removeButtonActoinPerformed  is even simpler, it uses standard JTable\n  functionality to remove any selected rows. The only thing clever here is that\n  rows are removed starting from the end to avoid having the index of later\n  selections change while deleting rows one at a time.       private void addButtonActionPerformed(ActionEvent evt) {                                          \n        // Open a file chooser pointing at the last opened directory.\n        JFileChooser fileChooser = GcodeFileTypeFilter.getGcodeFileChooser(\n            settings.getLastOpenedFilename());\n\n        int returnVal = fileChooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File gcodeFile = fileChooser.getSelectedFile();\n\n            // Save the new directory!\n            settings.setLastOpenedFilename(gcodeFile.getParent());\n\n            addFileToWorkflow(gcodeFile);\n        }  \n    }                                         \n\n    private void removeButtonActionPerformed(ActionEvent evt) {                                             \n        int[] selectedRows = fileTable.getSelectedRows();\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n        for (int i = selectedRows.length - 1; i  = 0; i--) {\n            int row = selectedRows[i]\n            this.model.removeRow(row);\n            this.model.fireTableRowsDeleted(row, row);\n        }\n    }                                              Up / Down Button Action Handlers   The up and down action buttons are pure java code. They don't do anything\n  you wouldn't do with any other Swing application. The code here deals strictly\n  with moving selections around. Although a little tricky, and not totally\n  relevant to UGS, they are included because the feature wouldn't be complete\n  without them.       private void upButtonActionPerformed(ActionEvent evt) {                                         \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[0] == 0) return;\n\n        for (int i = 0; i   selectedRows.length; i++) {\n            selectedRows[i] = this.moveRow(selectedRows[i], -1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    }                                        \n\n    private void downButtonActionPerformed(ActionEvent evt) {                                           \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[selectedRows.length-1]\n                == fileTable.getRowCount()) return;\n\n        for (int i = selectedRows.length - 1; i  = 0; i--) {\n            selectedRows[i] = this.moveRow(selectedRows[i], 1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    }   NetBeans Platform Component Lifecycle Code   Of the automatically generated methods,  componentOpened  is the only one\n  which needed some custom code. In case the component had been closed earlier\n  or wasn't loaded until after a file stream started, grab the  wasSending \n  state and save it for later.       @Override\n    public void componentOpened() {\n        this.wasSending = backend.isSending();\n    }\n\n    @Override\n    public void componentClosed() {\n        // No special close handling.\n    }\n\n    void writeProperties(java.util.Properties p) {\n        // better to version settings since initial version as advocated at\n        // http://wiki.apidesign.org/wiki/PropertyFiles\n        p.setProperty( version ,  1.0 );\n\n        // We could save the loaded files here\n    }\n\n    void readProperties(java.util.Properties p) {\n        String version = p.getProperty( version );\n\n        // We could load previously loaded files here\n    }  Helper Methods   Finally, here are the helper methods used above.       /**\n     * Look for the provided file in the file table.\n     */\n    private int findFileIndex(File gcodeFile) {\n        if (gcodeFile == null) return -1;\n\n        for (int i = 0; i   model.getRowCount(); i++) {\n            String file = (String) model.getValueAt(i, 0);\n            if (file != null   gcodeFile.getAbsolutePath().equals(file)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Move a given row by some offset. If the offset would move the row outside\n     * of the current table size, the row is not moved.\n     */\n    private int moveRow(int row, int offset) {\n        int dest = row + offset;\n        if (dest   0 || dest  = model.getRowCount()) {\n            return row;\n        }\n\n        model.moveRow(row, row, dest);\n        return dest;\n    }", 
            "title": "Annotated code"
        }, 
        {
            "location": "/dev/plugin/#conclusion", 
            "text": "Here is a quick screencast of what this plugin does for us. In the GUI builder I swapped in some up/down arrows compared to the tutorial.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/contrib/code/", 
            "text": "Code Contributions\n\n\nPull requests are welcome! Is there a feature you would like to see, or a bug\nthats been bothering you? Feel free to dig in. Not sure where to start? Ask on\ngithub, use an existing ticket or create a new one.\n\n\nIf you're planning to make a lot of changes please create an issue to discuss\nimplementation details. A lot of effort has gone into the current design so we\nwant to make sure everything will to work together.", 
            "title": "Code"
        }, 
        {
            "location": "/contrib/code/#code-contributions", 
            "text": "Pull requests are welcome! Is there a feature you would like to see, or a bug\nthats been bothering you? Feel free to dig in. Not sure where to start? Ask on\ngithub, use an existing ticket or create a new one.  If you're planning to make a lot of changes please create an issue to discuss\nimplementation details. A lot of effort has gone into the current design so we\nwant to make sure everything will to work together.", 
            "title": "Code Contributions"
        }, 
        {
            "location": "/contrib/translation/", 
            "text": "Translations\n\n\nTranslations are greatly appreciated.\n\n\nClassic GUI\n\n\nThe Classic GUI is localized with properties files found in \nsrc/resources\n.\n\n\n\n\nStart with \nMessagesBundle.properties\n\n\nRename to \nMessagesBundle_\nlocale\n.properties\n\n\nTranslate the file.\n\n\n\n\nIf you want to stop here, create a pull request and provide this file. I'm more\nthan happy to do the last steps.\n\n\nTo finish the job completely you'll need to know how to use \ngit\n.\n\n\n\n\nAdd your \n\n\nEdit \nsrc/com/willwinder/universalgcodesender/i18n/AvailableLanguages.java\n\n\nAdd your new translation to the \navailableLanguages\n object.\n\n\nCreate a pull request\n.\n\n\n\n\nUGS Platform\n\n\nNetBeans platform provides facilities for localization, but they have not been\nexplored yet. If you're interesting in exploring this, \nhere is the\ndocumentation\n, create an issue on github with anything you find out!", 
            "title": "Translations"
        }, 
        {
            "location": "/contrib/translation/#translations", 
            "text": "Translations are greatly appreciated.", 
            "title": "Translations"
        }, 
        {
            "location": "/contrib/translation/#classic-gui", 
            "text": "The Classic GUI is localized with properties files found in  src/resources .   Start with  MessagesBundle.properties  Rename to  MessagesBundle_ locale .properties  Translate the file.   If you want to stop here, create a pull request and provide this file. I'm more\nthan happy to do the last steps.  To finish the job completely you'll need to know how to use  git .   Add your   Edit  src/com/willwinder/universalgcodesender/i18n/AvailableLanguages.java  Add your new translation to the  availableLanguages  object.  Create a pull request .", 
            "title": "Classic GUI"
        }, 
        {
            "location": "/contrib/translation/#ugs-platform", 
            "text": "NetBeans platform provides facilities for localization, but they have not been\nexplored yet. If you're interesting in exploring this,  here is the\ndocumentation , create an issue on github with anything you find out!", 
            "title": "UGS Platform"
        }, 
        {
            "location": "/contrib/donation/", 
            "text": "Donation", 
            "title": "Donating"
        }, 
        {
            "location": "/contrib/donation/#donation", 
            "text": "", 
            "title": "Donation"
        }
    ]
}