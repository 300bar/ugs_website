{
    "docs": [
        {
            "location": "/",
            "text": "Universal Gcode Sender\n\n\n\n\n\n\nA full featured gcode platform used for interfacing with advanced CNC controllers like \nGRBL\n\nand \nTinyG\n.\nUniversal Gcode Sender is a self-contained Java application which includes all external dependencies,\nthat means if you have the Java Runtime Environment setup UGS provides the rest.\n\n\n\n\n  \n\n  \n\n  \n\n  \n\n\n\n\n\n\n\n\nDownloads\n\n\nSee the \nDownloads page\n.\n\n\n\n\nFeatures\n\n\n\n\nCross platform, tested on Windows, OSX, Linux, and Raspberry Pi.\n\n\nExecutable All-In-One JAR file - if you have java there is nothing to install. The JAR file includes native dependencies for all supported operating systems.\n\n\n3D Gcode Visualizer with color coded line segments and real time tool position feedback.\n\n\nDuration estimates.\n\n\nOver 3000 lines of unit test code, and another 1000 lines of comments documenting the tests.\n\n\nConfiguratble gcode optimization:\n\n\nRemove comments\n\n\nTruncate decimal precision to configurable amount\n\n\nConvert arcs (G2/G3) to line segments\n\n\nRemove whitespace\n\n\n\n\n\n\n\n\n\n\nGRBL 1.1 Features\n\n\n\n\n\n\nOverrides and Toggles \n\n    Platform version only. Easily control the real time feed and speed overrides by\n    enabling the Overrides widget in the Window menu.\n\n\n\n\n\n\n\n\n\n\n\nJog Mode \n\n    With older versions of GRBL UGS is pretty reliable when it comes to jogging, but\n    there are limitations. With GRBL 1.1 this is no longer the case when using the\n    new JOG MODE syntax. This first-class jog mode guarantees the GCODE state will\n    be unaltered, and also allows you to stop a jog while it is in progress. UGS\n    uses this new syntax automatically when it detects a version of GRBL which\n    supports it. During a jog use the STOP action to stop an in-progress jog:\n\n\n>> $J=G21G91X0.7F11\nok\n>> $J=G21G91Y0.7F11\nok\n>> $J=G21G91Z-0.7F11\nok\n\n\n\n\n\n\n\nPin State Reporting \n\n    Platform version only. New flags have been added to the controller state window\n    to indicate when various external switches are enabled.\n\n\n\n\n\n\n\n\n\n\n\nMessage resolution\n    GRBL removed most help and error messages to make room for new features on the\n    micro controller, they are now provided as data files in the grbl source code.\n    UGS uses these data files to resolve all error codes and setting strings.\n\n\n\n\n\n\n\n\nScreenshots\n\n\nPlatform\n\n\nThe next generation of UGS. Fully modular front end powered by the same robust\nlibrary created for the Classic GUI.\n\n\nFully modular GUI, reconfigure windows to suite your needs.\n\n\n\n\nBuilt in gcode editor with line highlighter.\n\n\n\n\nCustomizable keybindings.\n\n\n\n\nZoom to selection with command and drag.\n\n\n\n\nRight click in the visualizer to jog to a specific XY location.\n\n\n\n\nClassic\n\n\nThe classic GUI has everything you need to get started.\n\n\n3D visualizer.\n\n\n\n\nJob complete dialog.\n\n\n\n\nMachine control.\n\n\n\n\n\n\nDonations\n\n\nUniversal Gcode Sender is free software developed and maintained in my free time for the hobby cnc community. If you would like to make a monetary donation, all proceeds will be used to try convincing my wife that it is worth my time.\n\n\n\n  input[type=\"radio\"] {\n    margin: 0 5px 0 15px;\n  }\n  #donatebox {\n      text-align:center;\n      width: 300px;\n  }\n\n\n\n\n\n\n\n  \n\n  \n$1\n  \n$5\n  \n$10\n  \n\n  \n$25\n  \nCustom amount",
            "title": "Home"
        },
        {
            "location": "/#universal-gcode-sender",
            "text": "A full featured gcode platform used for interfacing with advanced CNC controllers like  GRBL \nand  TinyG .\nUniversal Gcode Sender is a self-contained Java application which includes all external dependencies,\nthat means if you have the Java Runtime Environment setup UGS provides the rest.",
            "title": "Universal Gcode Sender"
        },
        {
            "location": "/#downloads",
            "text": "See the  Downloads page .",
            "title": "Downloads"
        },
        {
            "location": "/#features",
            "text": "Cross platform, tested on Windows, OSX, Linux, and Raspberry Pi.  Executable All-In-One JAR file - if you have java there is nothing to install. The JAR file includes native dependencies for all supported operating systems.  3D Gcode Visualizer with color coded line segments and real time tool position feedback.  Duration estimates.  Over 3000 lines of unit test code, and another 1000 lines of comments documenting the tests.  Configuratble gcode optimization:  Remove comments  Truncate decimal precision to configurable amount  Convert arcs (G2/G3) to line segments  Remove whitespace",
            "title": "Features"
        },
        {
            "location": "/#grbl-11-features",
            "text": "Overrides and Toggles  \n    Platform version only. Easily control the real time feed and speed overrides by\n    enabling the Overrides widget in the Window menu.      Jog Mode  \n    With older versions of GRBL UGS is pretty reliable when it comes to jogging, but\n    there are limitations. With GRBL 1.1 this is no longer the case when using the\n    new JOG MODE syntax. This first-class jog mode guarantees the GCODE state will\n    be unaltered, and also allows you to stop a jog while it is in progress. UGS\n    uses this new syntax automatically when it detects a version of GRBL which\n    supports it. During a jog use the STOP action to stop an in-progress jog:  >> $J=G21G91X0.7F11\nok\n>> $J=G21G91Y0.7F11\nok\n>> $J=G21G91Z-0.7F11\nok    Pin State Reporting  \n    Platform version only. New flags have been added to the controller state window\n    to indicate when various external switches are enabled.      Message resolution\n    GRBL removed most help and error messages to make room for new features on the\n    micro controller, they are now provided as data files in the grbl source code.\n    UGS uses these data files to resolve all error codes and setting strings.",
            "title": "GRBL 1.1 Features"
        },
        {
            "location": "/#screenshots",
            "text": "",
            "title": "Screenshots"
        },
        {
            "location": "/#platform",
            "text": "The next generation of UGS. Fully modular front end powered by the same robust\nlibrary created for the Classic GUI.  Fully modular GUI, reconfigure windows to suite your needs.   Built in gcode editor with line highlighter.   Customizable keybindings.   Zoom to selection with command and drag.   Right click in the visualizer to jog to a specific XY location.",
            "title": "Platform"
        },
        {
            "location": "/#classic",
            "text": "The classic GUI has everything you need to get started.  3D visualizer.   Job complete dialog.   Machine control.",
            "title": "Classic"
        },
        {
            "location": "/#donations",
            "text": "Universal Gcode Sender is free software developed and maintained in my free time for the hobby cnc community. If you would like to make a monetary donation, all proceeds will be used to try convincing my wife that it is worth my time.  \n  input[type=\"radio\"] {\n    margin: 0 5px 0 15px;\n  }\n  #donatebox {\n      text-align:center;\n      width: 300px;\n  }   \n   \n   $1\n   $5\n   $10\n   \n   $25\n   Custom amount",
            "title": "Donations"
        },
        {
            "location": "/download/",
            "text": "Releases\n\n\n\n\n\n\n\n\nVersion\n\n\nJava Version Required\n\n\n\n\n\n\n\n\n\n\n1.0.9\n\n\n7+\n\n\n\n\n\n\n1.0.8\n\n\n7+\n\n\n\n\n\n\n1.0.7\n\n\n7+\n\n\n\n\n\n\n1.0.6\n\n\n6+\n\n\n\n\n\n\n\n\nOlder releases can be found \non github\n\n\n\n\n\n\nNightly Builds\n\n\nThese builds are generated automatically and contain all changes since the last release.\nUGS has a comprehensive set of automated tests and the build will not pass if any of the tests are failing.\n\n\nThe nightly builds now require Java 8\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClassic GUI\n\n\nThe classic UGS interface.\n\n\n\n\n\n\nUGS Platform\n\n\nThe next generation platform-based interface.\n\n\n\n\n\n\n\n\n\"Somewhat stable\" nightly build. In an effort to move towards a proper 2.0.0 release we have these \"Somewhat stable\" builds, they are similar to a release candidate but less formal.\n\n\nStable build from: \nJuly 28, 2017\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClassic GUI\n\n\nSome what stable UGS classic interface.\n\n\n\n\n\n\nUGS Platform\n\n\nSome what stable UPG next generation interface.",
            "title": "Download"
        },
        {
            "location": "/download/#releases",
            "text": "Version  Java Version Required      1.0.9  7+    1.0.8  7+    1.0.7  7+    1.0.6  6+     Older releases can be found  on github",
            "title": "Releases"
        },
        {
            "location": "/download/#nightly-builds",
            "text": "These builds are generated automatically and contain all changes since the last release.\nUGS has a comprehensive set of automated tests and the build will not pass if any of the tests are failing.  The nightly builds now require Java 8            Classic GUI  The classic UGS interface.    UGS Platform  The next generation platform-based interface.     \"Somewhat stable\" nightly build. In an effort to move towards a proper 2.0.0 release we have these \"Somewhat stable\" builds, they are similar to a release candidate but less formal. \nStable build from:  July 28, 2017           Classic GUI  Some what stable UGS classic interface.    UGS Platform  Some what stable UPG next generation interface.",
            "title": "Nightly Builds"
        },
        {
            "location": "/guide/common/",
            "text": "Common Features\n\n\nBecause the UGS Platform and the Classic GUI both build on the same foundation\nthey have a lot in common.\n\n\nGcode Processing\n\n\nError handling\n\n\nWhen GRBL reports an error while processing a line of gcode UGS will\nautomatically pause the stream. In some cases you might want to continue and\nignore the error in the future. The following dialog is displayed allowing you\nto do so:\n\n\n\n\n\n\n\n\nIf you select 'yes' at this point, a line will be added to the controller\noptions:",
            "title": "Common Features"
        },
        {
            "location": "/guide/common/#common-features",
            "text": "Because the UGS Platform and the Classic GUI both build on the same foundation\nthey have a lot in common.",
            "title": "Common Features"
        },
        {
            "location": "/guide/common/#gcode-processing",
            "text": "",
            "title": "Gcode Processing"
        },
        {
            "location": "/guide/common/#error-handling",
            "text": "When GRBL reports an error while processing a line of gcode UGS will\nautomatically pause the stream. In some cases you might want to continue and\nignore the error in the future. The following dialog is displayed allowing you\nto do so:     If you select 'yes' at this point, a line will be added to the controller\noptions:",
            "title": "Error handling"
        },
        {
            "location": "/guide/classic/",
            "text": "Classic Interface\n\n\nThis is the classic user interface. Initially designed as a bare-bones gcode\nsender it has grown in features since the initial release in 2012. It is built\nwith \nSwing\n using the \nNetBeans Builder\n built-in graphical GUI layout plugin.\nThe graphical nature of the plugin allows non-developers to tweak the interface\nwithout needing to write any code.\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nSelf-executing JAR, all native dependancies for Windows, OSX, Linux and\n    RaspberryPi are built in.\n\n\nGRBL and TinyG support, extensible interface for adding more.\n\n\n3D Gcode Visualizer.\n\n\nReal time machine feedback and control.\n\n\nBuilt in pendant - connect to UGS from your smart phone or tablet.\n\n\nConfigurable Gcode Processing - Remove comments, truncate decimals, expand arcs\n\n\nConstant memory usage - run any sized gcode file.\n\n\nExtensive development test suite for all core features.\n\n\nLocalized: Afrikaans, Italian, Spanish, German, French, Greek, Dutch, English\n\n\n\n\nHow to run\n\n\n\n\nDownload and install the version of Java listed on the download page, \nor a later version.\n\n\nDownload and extract the Classic GUI from one of the links here.\n\n\nOn most Operating Systems you can now double click the \nUniversalGcodeSender.jar\n file.\n   If double clicking does not work, execute \nstart-windows.bat\n on Windows or \nstart.sh\n on Linux or Mac OSX.\n\n\n\n\nUsage\n\n\n== TODO: Pull requests accepted! ==",
            "title": "Classic"
        },
        {
            "location": "/guide/classic/#classic-interface",
            "text": "This is the classic user interface. Initially designed as a bare-bones gcode\nsender it has grown in features since the initial release in 2012. It is built\nwith  Swing  using the  NetBeans Builder  built-in graphical GUI layout plugin.\nThe graphical nature of the plugin allows non-developers to tweak the interface\nwithout needing to write any code.",
            "title": "Classic Interface"
        },
        {
            "location": "/guide/classic/#features",
            "text": "Self-executing JAR, all native dependancies for Windows, OSX, Linux and\n    RaspberryPi are built in.  GRBL and TinyG support, extensible interface for adding more.  3D Gcode Visualizer.  Real time machine feedback and control.  Built in pendant - connect to UGS from your smart phone or tablet.  Configurable Gcode Processing - Remove comments, truncate decimals, expand arcs  Constant memory usage - run any sized gcode file.  Extensive development test suite for all core features.  Localized: Afrikaans, Italian, Spanish, German, French, Greek, Dutch, English",
            "title": "Features"
        },
        {
            "location": "/guide/classic/#how-to-run",
            "text": "Download and install the version of Java listed on the download page,  or a later version.  Download and extract the Classic GUI from one of the links here.  On most Operating Systems you can now double click the  UniversalGcodeSender.jar  file.\n   If double clicking does not work, execute  start-windows.bat  on Windows or  start.sh  on Linux or Mac OSX.",
            "title": "How to run"
        },
        {
            "location": "/guide/classic/#usage",
            "text": "== TODO: Pull requests accepted! ==",
            "title": "Usage"
        },
        {
            "location": "/guide/platform/",
            "text": "UGS Platform\n\n\nThe UGS Platform is the next generation of Universal Gcode Sender. It is built\nontop of the Netbeans Platform which allows us to leverage its mature modular\nframework. This platform allows more features to be added without compromising\non code quality, or being bogged down by a home grown framework. The Classic\nGUI is used as a library, so core features benefit both interfaces.\n\n\n\n\n\n\n\n\nPlatform Benefits\n\n\n\n\nThis is the current target for new UGS features.\n\n\nOut of the box dynamic windowing system allows arranging the UI dynamically.\n\n\nPlugin Framework available for decoupling features.\n\n\nHuge library of modules to leverage: Code Editors, Auto-updates, Keybindings\n\n\n\n\nHow to run\n\n\n\n\nDownload and install the version of Java listed on the download page, \nor a later version.\n\n\nDownload and extract the UGS Platform build from the downloads page.\n\n\nIn the locate \nbin\n in the \nugsplatform\n directory.\n\n\nOn Windows run \nugsplatform.exe\n or \nugsplatform64.exe\n, on Linux or Mac OSX run \nugsplatform\n.\n\n\n\n\nUsage\n\n\nController state (DRO)\n\n\nThe Controller state (or Digital Read Out) panel displays the current status of your machine. \n\n\n\n\nThe panel provides the following functions:\n\n\n\n\nCoordinates of both the machine and your current work\n\n\nButtons for resetting the work coordinates for each axis\n\n\nChangable work coordinates using simple mathematical expressions. \n You can either set an exact coordinate or, as an example, use the following \n# / 2\n to divide the current position in half. The \n#\n-character will be replaced with current position. If you start your expression with \n*\n or \n/\n the current position is prepended. \n \n\n\nDisplay the current machine state (Idle, Run, Jog, Alarm, etc.)\n\n\nDisplay the current feed rate and spindle speed\n\n\nDisplay the different GCode states\n\n\nDisplay alarm with the triggered limit switches",
            "title": "Platform"
        },
        {
            "location": "/guide/platform/#ugs-platform",
            "text": "The UGS Platform is the next generation of Universal Gcode Sender. It is built\nontop of the Netbeans Platform which allows us to leverage its mature modular\nframework. This platform allows more features to be added without compromising\non code quality, or being bogged down by a home grown framework. The Classic\nGUI is used as a library, so core features benefit both interfaces.",
            "title": "UGS Platform"
        },
        {
            "location": "/guide/platform/#platform-benefits",
            "text": "This is the current target for new UGS features.  Out of the box dynamic windowing system allows arranging the UI dynamically.  Plugin Framework available for decoupling features.  Huge library of modules to leverage: Code Editors, Auto-updates, Keybindings",
            "title": "Platform Benefits"
        },
        {
            "location": "/guide/platform/#how-to-run",
            "text": "Download and install the version of Java listed on the download page,  or a later version.  Download and extract the UGS Platform build from the downloads page.  In the locate  bin  in the  ugsplatform  directory.  On Windows run  ugsplatform.exe  or  ugsplatform64.exe , on Linux or Mac OSX run  ugsplatform .",
            "title": "How to run"
        },
        {
            "location": "/guide/platform/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/guide/platform/#controller-state-dro",
            "text": "The Controller state (or Digital Read Out) panel displays the current status of your machine.    The panel provides the following functions:   Coordinates of both the machine and your current work  Buttons for resetting the work coordinates for each axis  Changable work coordinates using simple mathematical expressions.   You can either set an exact coordinate or, as an example, use the following  # / 2  to divide the current position in half. The  # -character will be replaced with current position. If you start your expression with  *  or  /  the current position is prepended.     Display the current machine state (Idle, Run, Jog, Alarm, etc.)  Display the current feed rate and spindle speed  Display the different GCode states  Display alarm with the triggered limit switches",
            "title": "Controller state (DRO)"
        },
        {
            "location": "/guide/troubleshooting/",
            "text": "Common Problems\n\n\n\"Grbl has not finished booting.\"\n\n\nThis happens when UGS connects to a serial port and does not receive the GRBL startup string. Typically this is caused by a configuration problem and can be solved by one of the following:\n\n\n\n\nCheck the baud rate is 115200, or 9600 for very old versions of grbl.\n\n\nMake sure you are connecting to the correct port.\n\n\nMake sure you have installed any drivers required for your controller.\n\n\nMake sure GRBL is properly flashed on your controller.\n\n\n\n\nGcode program stopped working\n\n\nThe UGS Parser has a configurable list of rules to skip certain patterns, these rules are typically added by a Yes/No dialog asking if you would like to skip the erroneous commands in the future. Sometimes GRBL will get into an ALARM state and there will be lots of these popups which should not be skipped in the future.\n\n\n\n\n\n\n\n\nSkipping good commands may lead to broken gcode. Those rules should be removed from the gcode processor by going into the controller options.\n\n\nIn UGS Classic the option is in \nSettings > Gcode Processor Configuration\n.\n\n\nIn UGS Platform the option is under \nPreferences... > UGS > Controller Options\n.\n\n\nFor both, you need to uncheck or remove the invalid settings in the bottom list:\n\n\n\n\n\n\n\n\nPlatform Specific Issues\n\n\nToolbars or Windows don't appear.\n\n\nThis usually happens if you try running the platform without the required version of Java. The user cache is initialized but some objects become corrupt and initialization fails in the future even after upgrading Java.\n\n\nThis can be fixed by clearing out the user cache directory which can be found on the UGS \"About\" screen seen in the image below.\n\n\n\n\n\n\n\n\n\nInformation\n\n\nProperty Files\n\n\nClassic\n\n\nOccasionally it is useful to attach some of these property files to bug reports to help with reproducing a problem.\n\n\nClassic UGS properties are stored in your home directory, which changes based on the operating system being used:\n\n windows: /home/user/ugs\n\n mac: ~/Library/Preferences/ugs\n* linux: ~/ugs\n\n\nFiles include \nUniversalGcodeSender.json\n which contain different settings, and a \nfirmware_config\n directory which contains several configurations for different firmwares and testing profiles.\n\n\nPlatform\n\n\nThe platform version of UGS contains additional property files automatically created by the NetBeans Platform framework being used. These files are also contained in various locations based on the operating system being used. You can find the exact locations of these files in the About / Help menu (See screenshot above).\n\n\nIt is sometimes necessary to clear out these properties between major feature updates.\n\n\nOperating System Compatibility Problems\n\n\nLinux: Non Reparenting Window Managers\n\n\nThere are a number of window managers which are \"\nnon reparenting\n\", this causes some problems with Java.\n\n\nSome details about this problem \ncan be seen here\n.\n\n\nUse the \n_JAVA_AWT_WM_NONREPARENTING\n environment property to fix the problem:\n\n\nexport _JAVA_AWT_WM_NONREPARENTING=1",
            "title": "Help"
        },
        {
            "location": "/guide/troubleshooting/#common-problems",
            "text": "",
            "title": "Common Problems"
        },
        {
            "location": "/guide/troubleshooting/#grbl-has-not-finished-booting",
            "text": "This happens when UGS connects to a serial port and does not receive the GRBL startup string. Typically this is caused by a configuration problem and can be solved by one of the following:   Check the baud rate is 115200, or 9600 for very old versions of grbl.  Make sure you are connecting to the correct port.  Make sure you have installed any drivers required for your controller.  Make sure GRBL is properly flashed on your controller.",
            "title": "\"Grbl has not finished booting.\""
        },
        {
            "location": "/guide/troubleshooting/#gcode-program-stopped-working",
            "text": "The UGS Parser has a configurable list of rules to skip certain patterns, these rules are typically added by a Yes/No dialog asking if you would like to skip the erroneous commands in the future. Sometimes GRBL will get into an ALARM state and there will be lots of these popups which should not be skipped in the future.     Skipping good commands may lead to broken gcode. Those rules should be removed from the gcode processor by going into the controller options.  In UGS Classic the option is in  Settings > Gcode Processor Configuration .  In UGS Platform the option is under  Preferences... > UGS > Controller Options .  For both, you need to uncheck or remove the invalid settings in the bottom list:",
            "title": "Gcode program stopped working"
        },
        {
            "location": "/guide/troubleshooting/#platform-specific-issues",
            "text": "",
            "title": "Platform Specific Issues"
        },
        {
            "location": "/guide/troubleshooting/#toolbars-or-windows-dont-appear",
            "text": "This usually happens if you try running the platform without the required version of Java. The user cache is initialized but some objects become corrupt and initialization fails in the future even after upgrading Java.  This can be fixed by clearing out the user cache directory which can be found on the UGS \"About\" screen seen in the image below.",
            "title": "Toolbars or Windows don't appear."
        },
        {
            "location": "/guide/troubleshooting/#information",
            "text": "",
            "title": "Information"
        },
        {
            "location": "/guide/troubleshooting/#property-files",
            "text": "",
            "title": "Property Files"
        },
        {
            "location": "/guide/troubleshooting/#classic",
            "text": "Occasionally it is useful to attach some of these property files to bug reports to help with reproducing a problem.  Classic UGS properties are stored in your home directory, which changes based on the operating system being used:  windows: /home/user/ugs  mac: ~/Library/Preferences/ugs\n* linux: ~/ugs  Files include  UniversalGcodeSender.json  which contain different settings, and a  firmware_config  directory which contains several configurations for different firmwares and testing profiles.",
            "title": "Classic"
        },
        {
            "location": "/guide/troubleshooting/#platform",
            "text": "The platform version of UGS contains additional property files automatically created by the NetBeans Platform framework being used. These files are also contained in various locations based on the operating system being used. You can find the exact locations of these files in the About / Help menu (See screenshot above).  It is sometimes necessary to clear out these properties between major feature updates.",
            "title": "Platform"
        },
        {
            "location": "/guide/troubleshooting/#operating-system-compatibility-problems",
            "text": "",
            "title": "Operating System Compatibility Problems"
        },
        {
            "location": "/guide/troubleshooting/#linux-non-reparenting-window-managers",
            "text": "There are a number of window managers which are \" non reparenting \", this causes some problems with Java.  Some details about this problem  can be seen here .  Use the  _JAVA_AWT_WM_NONREPARENTING  environment property to fix the problem:  export _JAVA_AWT_WM_NONREPARENTING=1",
            "title": "Linux: Non Reparenting Window Managers"
        },
        {
            "location": "/dev/getting_started/",
            "text": "Project Organization\n\n\nUniversal Gcode Sender uses \nMaven\n to build the\nproject. It is using maven modules to separate the core library / classic GUI\nand the UGS Platform project. At the top level a \nUGS\n target defines the\n\nugs-core\n and \nugs-platform-parent\n modules which can be built separately or\nall at once.\n\n\nThe classic gui is part of the core project in the \nugs-core\n module. The\n\nmaven-shade-plugin\n and \nmaven-assembly-plugin\n are generate the\nself-executing JAR and distribution zip.\n\n\nUGS Platform is built on the \nNetBeans Platform\n.\nIt is also using maven.\n\n\nDevelopment is done using NetBeans, but most of the code can be edited using\nany IDE that supports Maven.\n\n\nDevelopment with an IDE\n\n\n\n\nAny IDE supporting Maven should be able to open the UGS project directory. Once\nopened it should show you the \nugs-core\n and \nugs-platform-parent\n modules\nwhich correspond to the Classic and Platform interfaces.\n\n\nDevelopment is done using NetBeans, and for some project development NetBeans\nis almost required. But for tweaking the UI and experimenting with the backend\nany IDE which supports maven can be used.\n\n\nClassic GUI\n\n\n\n\nIn the \nugs-core\n module, you can run the \nMainWindow.java\n file to start the\nClassic GUI.\n\n\nUGS Platform\n\n\n\n\nThe platform build has a number of submodules. Load the suite of modules by \nrunning the ugs-platform-app module.\n\n\nDevelopment with the Command Line\n\n\n\n\nThe UGS Classic and Platform interfaces can also be run from the command line.\nThese commands should be run from the root directory.\n\n\nClassic GUI\n\n\n\n\nThere is a helper script named \nrun_classic.sh\n, or you can use the commands below.\n\n\nRunning the UI\n\n\nmvn install\nmvn exec:java -Dexec.mainClass=\"com.willwinder.universalgcodesender.MainWindow\" -pl ugs-core\n\n\n\n\nExecuting tests\n\n\nmvn install\nmvn test -pl ugs-core\n\n\n\n\nBuilding the self-executing JAR\n\n\nmvn install\nmvn package -pl ugs-core\n\n\n\n\nBuilding a UniversalGcodeSender.zip release file\n\n\nmvn package assembly:assembly\n\n\n\n\nUGS Platform\n\n\n\n\nThere is a helper script named \nrun_platform.sh\n, or you can use the commands below.\n\n\nRunning the UI\n\n\nmvn install\nmvn nbm:run-platform -pl ugs-platform/application",
            "title": "Getting Started"
        },
        {
            "location": "/dev/getting_started/#project-organization",
            "text": "Universal Gcode Sender uses  Maven  to build the\nproject. It is using maven modules to separate the core library / classic GUI\nand the UGS Platform project. At the top level a  UGS  target defines the ugs-core  and  ugs-platform-parent  modules which can be built separately or\nall at once.  The classic gui is part of the core project in the  ugs-core  module. The maven-shade-plugin  and  maven-assembly-plugin  are generate the\nself-executing JAR and distribution zip.  UGS Platform is built on the  NetBeans Platform .\nIt is also using maven.  Development is done using NetBeans, but most of the code can be edited using\nany IDE that supports Maven.",
            "title": "Project Organization"
        },
        {
            "location": "/dev/getting_started/#development-with-an-ide",
            "text": "Any IDE supporting Maven should be able to open the UGS project directory. Once\nopened it should show you the  ugs-core  and  ugs-platform-parent  modules\nwhich correspond to the Classic and Platform interfaces.  Development is done using NetBeans, and for some project development NetBeans\nis almost required. But for tweaking the UI and experimenting with the backend\nany IDE which supports maven can be used.",
            "title": "Development with an IDE"
        },
        {
            "location": "/dev/getting_started/#classic-gui",
            "text": "In the  ugs-core  module, you can run the  MainWindow.java  file to start the\nClassic GUI.",
            "title": "Classic GUI"
        },
        {
            "location": "/dev/getting_started/#ugs-platform",
            "text": "The platform build has a number of submodules. Load the suite of modules by \nrunning the ugs-platform-app module.",
            "title": "UGS Platform"
        },
        {
            "location": "/dev/getting_started/#development-with-the-command-line",
            "text": "The UGS Classic and Platform interfaces can also be run from the command line.\nThese commands should be run from the root directory.",
            "title": "Development with the Command Line"
        },
        {
            "location": "/dev/getting_started/#classic-gui_1",
            "text": "There is a helper script named  run_classic.sh , or you can use the commands below.",
            "title": "Classic GUI"
        },
        {
            "location": "/dev/getting_started/#running-the-ui",
            "text": "mvn install\nmvn exec:java -Dexec.mainClass=\"com.willwinder.universalgcodesender.MainWindow\" -pl ugs-core",
            "title": "Running the UI"
        },
        {
            "location": "/dev/getting_started/#executing-tests",
            "text": "mvn install\nmvn test -pl ugs-core",
            "title": "Executing tests"
        },
        {
            "location": "/dev/getting_started/#building-the-self-executing-jar",
            "text": "mvn install\nmvn package -pl ugs-core",
            "title": "Building the self-executing JAR"
        },
        {
            "location": "/dev/getting_started/#building-a-universalgcodesenderzip-release-file",
            "text": "mvn package assembly:assembly",
            "title": "Building a UniversalGcodeSender.zip release file"
        },
        {
            "location": "/dev/getting_started/#ugs-platform_1",
            "text": "There is a helper script named  run_platform.sh , or you can use the commands below.",
            "title": "UGS Platform"
        },
        {
            "location": "/dev/getting_started/#running-the-ui_1",
            "text": "mvn install\nmvn nbm:run-platform -pl ugs-platform/application",
            "title": "Running the UI"
        },
        {
            "location": "/dev/backend_development/",
            "text": "Backend architecture\n\n\nSimilar to the front-end there are more layers on the backend to help with\nsupporting differences between different gcode controllers and the different\nways to communicate with these controllers. Because UGS depends on serial\nevents from CNC devices, the communication between layers is also event driven.\nThis is implemented using a series of \nListener\n classes which pass messages\nfrom the lower levels to the upper levels whenever data is detected on the\nserial port (USB).\n\n\nController\n\n\nA controller is primarily responsible for implementing controller-specific\nfeatures. Different features can be things like what happens when a\n\nPerform Homing\n command is requested, or how to issue status requests and\nparse their results. \nGRBL\n and \nTinyG\n are both supported, they share a\nlot of code with the \nAbstractController.java\n abstract class.\n\n\nInternally the \nAbstractController\n class implements several important\nthings. It manages the stream lifecycle, keeping track of which commands have\nbeen sent, which have been completed and in some cases which are queued for\nsending. The controller also figures out when the stream has finished. Finally\nthe \nAbstractController\n implements the \nSerialCommunicatorListener\n, which\nhow its able to detect all of this state information (and allows commands to\nbe sent to the CNC controller).\n\n\nThe controller provides a \nControllerListener\n interface which is used to\nprovide real time status.\n\n\nFinally, the \nAbstractController\n defines a number of abstract methods which\ncan be used by device specific controllers as needed to hook into important\nlifecycle events:\n\n\n    abstract protected void closeCommBeforeEvent();\n    abstract protected void closeCommAfterEvent();\n    protected void openCommAfterEvent() throws Exception {}\n    abstract protected void cancelSendBeforeEvent();\n    abstract protected void cancelSendAfterEvent();\n    abstract protected void pauseStreamingEvent() throws Exception;\n    abstract protected void resumeStreamingEvent() throws Exception;\n    abstract protected void isReadyToSendCommandsEvent() throws Exception;\n    abstract protected void statusUpdatesEnabledValueChanged(boolean enabled);\n    abstract protected void statusUpdatesRateValueChanged(int rate);\n\n    // This one is special, because it is responsible for parsing device\n    // responses, such as a command complete, status string, or parsing a\n    // status event. In the case of a command complete, it must call\n    // `commandComplete` to push the stream lifecycle along.\n    abstract protected void rawResponseHandler(String response);\n\n\n\n\nHere is the public interface which controlles conform to:\n\n\npublic interface IController {\n    /*\n    Observable\n    */\n    public void addListener(ControllerListener cl);\n\n    /*\n    Actions\n    */\n    public void performHomingCycle() throws Exception;\n    public void returnToHome() throws Exception;\n    public void resetCoordinatesToZero() throws Exception;\n    public void resetCoordinateToZero(final char coord) throws Exception;\n    public void killAlarmLock() throws Exception;\n    public void toggleCheckMode() throws Exception;\n    public void viewParserState() throws Exception;\n    public void issueSoftReset() throws Exception;\n\n    /*\n    Behavior\n    */\n    public void setSingleStepMode(boolean enabled);\n    public boolean getSingleStepMode();\n\n    public void setStatusUpdatesEnabled(boolean enabled);\n    public boolean getStatusUpdatesEnabled();\n\n    public void setStatusUpdateRate(int rate);\n    public int getStatusUpdateRate();\n\n    public GcodeCommandCreator getCommandCreator();\n    public long getJobLengthEstimate(File gcodeFile);\n\n    /*\n    Serial\n    */\n    public Boolean openCommPort(String port, int portRate) throws Exception;\n    public Boolean closeCommPort() throws Exception;\n    public Boolean isCommOpen();\n\n    /*\n    Stream information\n    */\n    public Boolean isReadyToStreamFile() throws Exception;\n    public Boolean isStreamingFile();\n    public long getSendDuration();\n    public int rowsInSend();\n    public int rowsSent();\n    public int rowsRemaining();\n\n    /*\n    Stream control\n    */\n    public void beginStreaming() throws Exception;\n    public void pauseStreaming() throws Exception;\n    public void resumeStreaming() throws Exception;\n    public void cancelSend();\n\n    /*\n    Stream content\n    */\n    public GcodeCommand createCommand(String gcode) throws Exception;\n    public void sendCommandImmediately(GcodeCommand cmd) throws Exception;\n    public void queueCommand(GcodeCommand cmd) throws Exception;\n    public void queueStream(GcodeStreamReader r);\n    public void queueRawStream(Reader r);\n}\n\n\n\n\nCommunicator\n\n\nA communicator handles all levels of sending data to the device. Raw responses\nare returned to any listeners via the \nSerialCommunicatorListener\n.\n\n\nThe \nAbstractCommunicator\n implements several listener utilities which are used\nby implementing classes.\n\n\nThe \nBufferedCommunicator\n abstract class handles the process of buffering\nmultiple commands at once in order to keep a constant stream of commands\navailable to the CNC device. It does this in the \nstreamCommands\n method by\nmaintaining a list of active commands, and the current size of those commands. A\nmethod named \nprocessedCommand\n must be implemented in a subclass to determine\nwhether a raw response indicates a command has completed. This notifies the\n\nBufferedCommunicator\n that it should attempt to send more commands.\n\n\nGrblCommunicator\n and \nTinyGCommunicator\n are two concrete implementations of\nthe \nBufferedCommunicator\n.\n\n\nConnection\n\n\nThis is a very thin layer which provides a way to write and receive data:\n\n\n    abstract public boolean openPort(String name, int baud) throws Exception;\n    abstract public void closePort() throws Exception;\n    abstract public boolean isOpen();\n    abstract public void sendByteImmediately(byte b) throws Exception;\n    abstract public void sendStringToComm(String command) throws Exception;\n\n\n\n\nStreaming strategy\n\n\nUGS attempts to use a fixed amount of memory when streaming a file. In this way\nit can send gcode files of any size. Files are preprocessed at the \nBackendAPI\n\nlevel using the \nGcodeStreamWriter\n class. This will serialize all the required\nmetadata into a file. Later on that file can be opened with the\n\nGcodeStreamReader\n class, the \nController\n and \nCommunicator\n classes use\nthis. Using the reader, the \nCommunicator\n class can pull out commands one at\na time and send them to the \nConnection\n.",
            "title": "Backend"
        },
        {
            "location": "/dev/backend_development/#backend-architecture",
            "text": "Similar to the front-end there are more layers on the backend to help with\nsupporting differences between different gcode controllers and the different\nways to communicate with these controllers. Because UGS depends on serial\nevents from CNC devices, the communication between layers is also event driven.\nThis is implemented using a series of  Listener  classes which pass messages\nfrom the lower levels to the upper levels whenever data is detected on the\nserial port (USB).",
            "title": "Backend architecture"
        },
        {
            "location": "/dev/backend_development/#controller",
            "text": "A controller is primarily responsible for implementing controller-specific\nfeatures. Different features can be things like what happens when a Perform Homing  command is requested, or how to issue status requests and\nparse their results.  GRBL  and  TinyG  are both supported, they share a\nlot of code with the  AbstractController.java  abstract class.  Internally the  AbstractController  class implements several important\nthings. It manages the stream lifecycle, keeping track of which commands have\nbeen sent, which have been completed and in some cases which are queued for\nsending. The controller also figures out when the stream has finished. Finally\nthe  AbstractController  implements the  SerialCommunicatorListener , which\nhow its able to detect all of this state information (and allows commands to\nbe sent to the CNC controller).  The controller provides a  ControllerListener  interface which is used to\nprovide real time status.  Finally, the  AbstractController  defines a number of abstract methods which\ncan be used by device specific controllers as needed to hook into important\nlifecycle events:      abstract protected void closeCommBeforeEvent();\n    abstract protected void closeCommAfterEvent();\n    protected void openCommAfterEvent() throws Exception {}\n    abstract protected void cancelSendBeforeEvent();\n    abstract protected void cancelSendAfterEvent();\n    abstract protected void pauseStreamingEvent() throws Exception;\n    abstract protected void resumeStreamingEvent() throws Exception;\n    abstract protected void isReadyToSendCommandsEvent() throws Exception;\n    abstract protected void statusUpdatesEnabledValueChanged(boolean enabled);\n    abstract protected void statusUpdatesRateValueChanged(int rate);\n\n    // This one is special, because it is responsible for parsing device\n    // responses, such as a command complete, status string, or parsing a\n    // status event. In the case of a command complete, it must call\n    // `commandComplete` to push the stream lifecycle along.\n    abstract protected void rawResponseHandler(String response);  Here is the public interface which controlles conform to:  public interface IController {\n    /*\n    Observable\n    */\n    public void addListener(ControllerListener cl);\n\n    /*\n    Actions\n    */\n    public void performHomingCycle() throws Exception;\n    public void returnToHome() throws Exception;\n    public void resetCoordinatesToZero() throws Exception;\n    public void resetCoordinateToZero(final char coord) throws Exception;\n    public void killAlarmLock() throws Exception;\n    public void toggleCheckMode() throws Exception;\n    public void viewParserState() throws Exception;\n    public void issueSoftReset() throws Exception;\n\n    /*\n    Behavior\n    */\n    public void setSingleStepMode(boolean enabled);\n    public boolean getSingleStepMode();\n\n    public void setStatusUpdatesEnabled(boolean enabled);\n    public boolean getStatusUpdatesEnabled();\n\n    public void setStatusUpdateRate(int rate);\n    public int getStatusUpdateRate();\n\n    public GcodeCommandCreator getCommandCreator();\n    public long getJobLengthEstimate(File gcodeFile);\n\n    /*\n    Serial\n    */\n    public Boolean openCommPort(String port, int portRate) throws Exception;\n    public Boolean closeCommPort() throws Exception;\n    public Boolean isCommOpen();\n\n    /*\n    Stream information\n    */\n    public Boolean isReadyToStreamFile() throws Exception;\n    public Boolean isStreamingFile();\n    public long getSendDuration();\n    public int rowsInSend();\n    public int rowsSent();\n    public int rowsRemaining();\n\n    /*\n    Stream control\n    */\n    public void beginStreaming() throws Exception;\n    public void pauseStreaming() throws Exception;\n    public void resumeStreaming() throws Exception;\n    public void cancelSend();\n\n    /*\n    Stream content\n    */\n    public GcodeCommand createCommand(String gcode) throws Exception;\n    public void sendCommandImmediately(GcodeCommand cmd) throws Exception;\n    public void queueCommand(GcodeCommand cmd) throws Exception;\n    public void queueStream(GcodeStreamReader r);\n    public void queueRawStream(Reader r);\n}",
            "title": "Controller"
        },
        {
            "location": "/dev/backend_development/#communicator",
            "text": "A communicator handles all levels of sending data to the device. Raw responses\nare returned to any listeners via the  SerialCommunicatorListener .  The  AbstractCommunicator  implements several listener utilities which are used\nby implementing classes.  The  BufferedCommunicator  abstract class handles the process of buffering\nmultiple commands at once in order to keep a constant stream of commands\navailable to the CNC device. It does this in the  streamCommands  method by\nmaintaining a list of active commands, and the current size of those commands. A\nmethod named  processedCommand  must be implemented in a subclass to determine\nwhether a raw response indicates a command has completed. This notifies the BufferedCommunicator  that it should attempt to send more commands.  GrblCommunicator  and  TinyGCommunicator  are two concrete implementations of\nthe  BufferedCommunicator .",
            "title": "Communicator"
        },
        {
            "location": "/dev/backend_development/#connection",
            "text": "This is a very thin layer which provides a way to write and receive data:      abstract public boolean openPort(String name, int baud) throws Exception;\n    abstract public void closePort() throws Exception;\n    abstract public boolean isOpen();\n    abstract public void sendByteImmediately(byte b) throws Exception;\n    abstract public void sendStringToComm(String command) throws Exception;",
            "title": "Connection"
        },
        {
            "location": "/dev/backend_development/#streaming-strategy",
            "text": "UGS attempts to use a fixed amount of memory when streaming a file. In this way\nit can send gcode files of any size. Files are preprocessed at the  BackendAPI \nlevel using the  GcodeStreamWriter  class. This will serialize all the required\nmetadata into a file. Later on that file can be opened with the GcodeStreamReader  class, the  Controller  and  Communicator  classes use\nthis. Using the reader, the  Communicator  class can pull out commands one at\na time and send them to the  Connection .",
            "title": "Streaming strategy"
        },
        {
            "location": "/dev/frontend_development/",
            "text": "Front-end Architecture\n\n\nUGS uses a Model-View-Presenter architecture. What this means is that at a high\nlevel there are three layers which each serve different purposes. A \nModel\n\nfor all backend logic, a \nView\n displayed to the user and a \nPresenter\n\nwhich serves as a buffer between the model and one or more views.\n\n\nModel\n\n\nThe model contains all backend logic. Things like opening a connection, listing\nserial ports, streaming a file, and handling firmware specific nuances. All of\nthis is hidden from the front end as much as possible.\n\n\nView\n\n\nThe view only has access to the presenter. It is responsible for all user\ninteraction and feedback. The main logic in here should be things like\nenabling or disabling components based on the current state of the model.\n\n\nClassic GUI\n\n\nThe \nClassic GUI\n is built using NetBeans. There are a number of custom Swing\ncomponents, and they are all initialized with the NetBeans GUI builder. The\nvast majority of the \nClassic GUI\n code is contained in \nMainWindow.java\n.\nThere isn't a lot to expand on here, this front end has grown organically over\nthe years and is fairly rigid. The \nVisualizer\n component is a standalone\nJOGL window which is updated using events from the backend (it was a model for\nmany of the improvements in the current applications architecture).\n\n\nUGS Platform\n\n\nThe \nUGS Platform\n build is also built using NetBeans. It is a built ontop of\nthe NetBeans Platform which provides it a robust set of tools like flexible\nwindows, a plugin framework, and a suite of tools for module communications. At\nthe core of this is a module named \nUGSLib\n which is a simple wrapper to the\nstandard UGS JAR file. There is a suite of modules named \nUGSCore\n which\nprovides many of the standard UI elements seen in the \nClassic GUI\n, in\naddition there are other modules that provide new functionality.\n\n\nExtending the GUI is now a matter of creating a new plugin, for details on how\nto do this see the \nPlugin Tutorial\n.\n\n\nPresenter\n\n\nThe presenter serves as an API for the model. All the heavy lifting needed for\nthe GUI should happen here. For example the controller model object knows how\nto stream a processed file, but it doesn't know how to process the file. So the\npresenter will pass data to the gcode processor and generate a processed object\nwhich can be passed to the controller.\n\n\nSimilarly, all notifications from the model are reinterpreted for the view with\na simpler message strategy.\n\n\nIn this way, all updates to the backend code can be leveraged by all front ends\nwhich utilize UGS.\n\n\nBackendAPI\n\n\nIn UGS interfaces named \nBackendAPI\n and \nBackendAPIReadOnly\n provide the\npresenter layer. The read only methods are split off into a sub-interface in\ncase a developer wants to be sure they don't change any state. For instance a\nwidget that displays the current machine location probably has no need for\npausing a stream.\n\n\nThese APIs are used by all front ends (\nClassic GUI\n, \nPendantUI\n and\n\nUGS Platform\n).",
            "title": "Frontend"
        },
        {
            "location": "/dev/frontend_development/#front-end-architecture",
            "text": "UGS uses a Model-View-Presenter architecture. What this means is that at a high\nlevel there are three layers which each serve different purposes. A  Model \nfor all backend logic, a  View  displayed to the user and a  Presenter \nwhich serves as a buffer between the model and one or more views.",
            "title": "Front-end Architecture"
        },
        {
            "location": "/dev/frontend_development/#model",
            "text": "The model contains all backend logic. Things like opening a connection, listing\nserial ports, streaming a file, and handling firmware specific nuances. All of\nthis is hidden from the front end as much as possible.",
            "title": "Model"
        },
        {
            "location": "/dev/frontend_development/#view",
            "text": "The view only has access to the presenter. It is responsible for all user\ninteraction and feedback. The main logic in here should be things like\nenabling or disabling components based on the current state of the model.",
            "title": "View"
        },
        {
            "location": "/dev/frontend_development/#classic-gui",
            "text": "The  Classic GUI  is built using NetBeans. There are a number of custom Swing\ncomponents, and they are all initialized with the NetBeans GUI builder. The\nvast majority of the  Classic GUI  code is contained in  MainWindow.java .\nThere isn't a lot to expand on here, this front end has grown organically over\nthe years and is fairly rigid. The  Visualizer  component is a standalone\nJOGL window which is updated using events from the backend (it was a model for\nmany of the improvements in the current applications architecture).",
            "title": "Classic GUI"
        },
        {
            "location": "/dev/frontend_development/#ugs-platform",
            "text": "The  UGS Platform  build is also built using NetBeans. It is a built ontop of\nthe NetBeans Platform which provides it a robust set of tools like flexible\nwindows, a plugin framework, and a suite of tools for module communications. At\nthe core of this is a module named  UGSLib  which is a simple wrapper to the\nstandard UGS JAR file. There is a suite of modules named  UGSCore  which\nprovides many of the standard UI elements seen in the  Classic GUI , in\naddition there are other modules that provide new functionality.  Extending the GUI is now a matter of creating a new plugin, for details on how\nto do this see the  Plugin Tutorial .",
            "title": "UGS Platform"
        },
        {
            "location": "/dev/frontend_development/#presenter",
            "text": "The presenter serves as an API for the model. All the heavy lifting needed for\nthe GUI should happen here. For example the controller model object knows how\nto stream a processed file, but it doesn't know how to process the file. So the\npresenter will pass data to the gcode processor and generate a processed object\nwhich can be passed to the controller.  Similarly, all notifications from the model are reinterpreted for the view with\na simpler message strategy.  In this way, all updates to the backend code can be leveraged by all front ends\nwhich utilize UGS.",
            "title": "Presenter"
        },
        {
            "location": "/dev/frontend_development/#backendapi",
            "text": "In UGS interfaces named  BackendAPI  and  BackendAPIReadOnly  provide the\npresenter layer. The read only methods are split off into a sub-interface in\ncase a developer wants to be sure they don't change any state. For instance a\nwidget that displays the current machine location probably has no need for\npausing a stream.  These APIs are used by all front ends ( Classic GUI ,  PendantUI  and UGS Platform ).",
            "title": "BackendAPI"
        },
        {
            "location": "/dev/plugin/",
            "text": "Note: The UGS Platform has been updated to use maven. Some parts of this document need to be updated to reflect that change.\n\n\n\n\n\n\nPlugin development\n\n\nThe UGS Platform is built ontop of the NetBeans Platform. This gives us powerful\ntools to work with, including a robust plugin system. The heart of the UGS\nPlatform is a module which wraps and exposes the Universal Gcode Sender JAR\nfile - the same jar you could execute to run the Classic GUI! Other than using\nthe UGSLib module, developing a plugin for the UGS Platform is exactly the same\nas developing any other NetBeans Platform plugin. And there is lots of great\ndocumentation for that, here is the \nNetBeans Platform Plugin Quick Start\n\nguide.\n\n\nWorkflow Plugin Tutorial\n\n\nIn this tutorial we're going to build a window to help manage jobs that use\nmultiple tools which are split into multiple files. The rough design idea will\nhave a central table with four columns containing:\n\n File name\n\n Tool name (editable)\n* Finished flag\n\n\nThere will be a pair of buttons to add and remove files from the table, and\nwe will also hook up a UGS event listener to detect when files are opened from\nother areas of the interface as well.\n\n\nLastly, we'll add another pair of buttons to move rows around in the table, so\nthat we can reorganize the workflow if files were added out of order the order.\n\n\nHere is a sketch of what we're building:\n\n\n\nCreate and configure project\n\n\nUniversal Gcode Sender is developed with NetBeans, and plugins are no exception.\nOnce you've cloned the Universal Gcode Sender project you should be able to open\nthe UGSPlatform folder with NetBeans and it will discover a project that you can open.\nTo start building your module expand the UGSPlatform section, right-click the\nmodules directory and select \nAdd New...\n.\n\n\n\n\nThis will open up a wizard where you name the module, and declare the source\npath. For this example the module is named WorkflowModuleTutorial and the source\npath is com.willwinder.ugs.nbp.workflowmoduletutorial which is the convention\nused in the core modules.\n\n\n\n\nAdd UGS dependencies\n\n\nYour module should now be listed in the Modules section. If it doesn't you may\nneed to restart NetBeans. Before we dive into the code there are a couple helper\nclasses to import which will give you full access to the UGS API. Double click\nyour module from the Modules section to open the code, then right-click the top\nlevel item which appeared and select the properties menu.\n\n\nSelect \nAdd Dependency...\n, here you should search for \nUGSLib\n and\n\nCentralLookup\n then add them to your plugin.\n\n\n\n\nCreate window class\n\n\nNow we're ready to build the module. In this tutorial we're building a window\nto manage a multi-job workflow, so we'll start by adding a window to customize.\n\n\n\n\nOpen the new module and right click the new package, in the context menu go to\n\nNew\n -> \nWindow...\n. To bring up the new window wizard.\n\n\nIn the first screen of the wizard choose the default location your window\nwill appear. Custom locations have been designed for UGS Platform, the largest\nis named \nvisualizer\n because it is the Visualizer's default location. We'll\nuse this location for our plugin.  This means that when our plugin opens it will\nbe tabbed with the Visualizer module.\n\n\nClick next and choose a class name for your module, for this tutorial I'm\ngoing to call it \nWorkflowModuleTutorial\n.\n\n\n\n\n\n\nBuild the GUI\n\n\nThe NetBeans GUI builder makes it easy to make a custom user interface without\nwriting a single line of code (which is the main reason UGS uses NetBeans!).\nUsing the GUI builder we'll add some buttons and a table. This step can be as\nelaborate as you want. If you're a seasoned swing developer and prefer not to\nuse the magic GUI builder, no worries, you can create the UI programatically as\nwell - but that is a different tutorial.\n\n\n\n\nTake a look at the screenshot below. The \n[TopComponent] - Navigator - Editor\n\n  window shows all the objects that have been added with the GUI builder.\n\n\nThere are four JButtons, a JTable nested inside a JScrollPane and a JPanel\n  which I used to make alignment a little easier (The GUI Builder is powerful,\n  but it can also be a bit quirky).\n\n\nPutting the JTable inside a JScrollPane makes it so that if too many items\n  get added to the table it will scroll rather than dissapear off the bottom.\n\n\nNote:\n The name given to these components will be used in the code, so\n  be sure to use the names shown in the screenshot.\n\n\n\n\n\n\nThe JTable is going to be the trickiest part of build the GUI. To configure the\ntable right-click the JTable object from the component navigator and select\n\nTable Contents...\n. Here you can add our 3 columns and specify that the data\ntypes. You can also specify which columns are editable, in this example we want\nthe user to be able to type in what type of tool should be used.\n\n\n\n\nAutogenerated code\n\n\nBefore writing any code, lets take a look at what has already been automatically\ngenerated for us.\n\n\n\n\n\n\nJust above the class there are a number of annotations. These are used by\n   the NetBeans platform, most of them were setup according to how you filled\n   in the Wizards earlier. They can also configure things like keyboard\n   shortcuts, and where things are put in the dropdown menus.\n\n\n\n\n\n\nWithin the class there are several grayed out sections. This is code\n   generated by NetBeans which the IDE prevents you from modifying outside the\n   GUI builder or in some cases component properties. For example if you wanted\n   to use a custom JTable, you would configure the table in the GUI builder by\n   adding a custom constructor.\n\n\n\n\n\n\nAt the end of the file is \ncomponentOpened\n and \ncomponentClosed\n, these are\n   lifecycle events that are called when the window has been opened or closed.\n\n\n\n\n\n\nAlso at the end of the file is \nwriteProperties\n and \nreadProperties\n, these\n   are used to save the window state between runs.\n\n\n\n\n\n\nAnnotated code\n\n\nThis is the longest section because it will explain every line of code added to\nthe \nWorkflowModuleTutorial\n class. The most complicated code deals with Swing\ncomponent manipulation, with just a smattering of UGS lifecycle events to push\nthings along.\n\n\nClass signature\n\n\n\n\nFirst there are a few class state object we'll need and two Listeners we'll\n  be implementing.\n\n\n\n\n/**\n * UGSEventListener - this is how a plugin can listen to UGS lifecycle events.\n * ListSelectionListener - listen for table selections.\n */\npublic final class WorkflowWindowTutorialTopComponent\n        extends TopComponent\n        implements UGSEventListener, ListSelectionListener {\n\n    // These are the UGS backend objects for interacting with the backend.\n    private final Settings settings;\n    private final BackendAPI backend;\n\n    // This is used to identify when a stream has completed.\n    private boolean wasSending;\n\n    // This is used in most methods, so cache it here.\n    DefaultTableModel model;\n\n\n\n\nConstructor\n\n\n\n\nIn the constructor we register the class with the UGS backend and also set\n  the class as a listener to table selection events.\n\n\n\n\n    public WorkflowWindowTopComponent() {\n        initComponents();\n        setName(Bundle.CTL_WorkflowWindowTopComponent());\n        setToolTipText(Bundle.HINT_WorkflowWindowTopComponent());\n\n        // This is how to access the UGS backend and register the listener.\n        // CentralLookup is used to get singleton instances of the UGS\n        // Settings and BackendAPI objects.\n        settings = CentralLookup.getDefault().lookup(Settings.class);\n        backend = CentralLookup.getDefault().lookup(BackendAPI.class);\n        backend.addUGSEventListener(this);\n\n        // Allow contiguous ranges of selections and register a listener.\n        this.fileTable.setSelectionMode(\n            ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n        ListSelectionModel cellSelectionModel =\n            this.fileTable.getSelectionModel();\n        cellSelectionModel.addListSelectionListener(this);\n\n        // Cache the model object.\n        model = (DefaultTableModel)this.fileTable.getModel();\n    }\n\n\n\n\nUGS Event Listener\n\n\n\n\nThis is the event sent from the UGS Backend, when a file is loaded or the\n  state changes a notification will be sent.\n\n\nIf the state switches from \nCOMM_SENDING\n to \nCOMM_IDLE\n we'll run a\n  \ncompleteFile\n method.\n\n\nIf a file is loaded, we add it to the table.\n\n\n\n\n    @Override\n    public void UGSEvent(UGSEvent cse) {\n        if (cse.isStateChangeEvent()) {\n            if (wasSending && cse.getControlState() == ControlState.COMM_IDLE)\n               this.completeFile(backend.getGcodeFile());\n            wasSending = backend.isSending();\n        }\n        if (cse.isFileChangeEvent()) {\n            this.addFileToWorkflow(backend.getGcodeFile());\n        }\n\n    }\n\n\n\n\nFile Complete Handler\n\n\n\n\nWhen a command is complete we'll update the JTable, select the next file that\n  needs to be sent and popup a notification informing the user what they should\n  do next. The selection event will be sent and handled in the selection\n  handler.\n\n\n\n\n    public void completeFile(File gcodeFile) {\n        if (gcodeFile == null) return;\n\n        // Make sure the file is loaded in the table.\n        int fileIndex = findFileIndex(gcodeFile);\n        if (fileIndex < 0) return;\n\n        // Mark that it has been completed.\n        model.setValueAt(true, fileIndex, 2);\n\n        fileIndex++;\n        String message;\n\n        // Make sure there is another command left.\n        if (fileIndex < fileTable.getRowCount()) {\n            String nextTool = (String) model.getValueAt(fileIndex, 1);\n            String messageTemplate =\n                   \"Finished sending '%s'.\\n\"\n                 + \"The next file uses tool '%s'\\n\"\n                 + \"Load tool and move machine to its zero location\\n\"\n                 + \"and click send to continue this workflow.\";\n            message = String.format(\n                messageTemplate, gcodeFile.getName(), nextTool);\n\n            // Select the next row, this will trigger a selection event.\n            fileTable.setRowSelectionInterval(fileIndex, fileIndex);\n\n        // Use a different message if we're finished.\n        } else {\n            message = \"Finished sending the last file!\";\n        }\n\n        // Display a notification.\n        java.awt.EventQueue.invokeLater(() -> {\n            JOptionPane.showMessageDialog(new JFrame(), message, \n                    \"Workflow Event\", JOptionPane.PLAIN_MESSAGE);\n        });\n    }\n\n\n\n\nJTable Selection Listener\n\n\n\n\nThis is the selection listener, when a file is selected load it in the backend.\n\n\n\n\n    @Override\n    public void valueChanged(ListSelectionEvent e) {\n        int[] selectedRow = fileTable.getSelectedRows();\n        // Only load files when there is a single selection.\n        if (selectedRow.length == 1) {\n            // Pull the file out of the table and set it in the backend.\n            String file = (String) model.getValueAt(selectedRow[0], 0);\n            try {\n                backend.setGcodeFile(new File(file));\n            } catch (Exception ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        }\n    }\n\n\n\n\nJTable Helper\n\n\n\n\nHelper method to add a file to the JTable, first making sure that it isn't\n  already in the table.\n\n\n\n\n    public void addFileToWorkflow(File gcodeFile) {\n        if (gcodeFile == null) {\n            return;\n        }\n\n        int fileIndex = findFileIndex(gcodeFile);\n        // Don't re-add a file.\n        if (fileIndex >= 0) {\n            return;\n        }\n\n        model.addRow(new Object[]{\n                gcodeFile.getAbsolutePath(),\n                \"default\",\n                false\n            });\n\n        // Fire off the selection event to load the file.\n        int lastRow = fileTable.getRowCount() - 1;\n        fileTable.setRowSelectionInterval(lastRow, lastRow);\n    }\n\n\n\n\nAdd/Remove Button Action Handlers\n\n\n\n\nNow we implement the button event methods. They are generated by double\n  clicking the buttons in the GUI Builder. This generates the swing code that\n  attaches the \nActionPerformed\n events to the button click callbacks.\n\n\naddButtonActionPerformed\n simply displays a file chooser (using some UGS\n  library built ins) and calls the \naddFileToWorkflow\n method defined earlier.\n\n\nremoveButtonActoinPerformed\n is even simpler, it uses standard JTable\n  functionality to remove any selected rows. The only thing clever here is that\n  rows are removed starting from the end to avoid having the index of later\n  selections change while deleting rows one at a time.\n\n\n\n\n    private void addButtonActionPerformed(ActionEvent evt) {                                          \n        // Open a file chooser pointing at the last opened directory.\n        JFileChooser fileChooser = GcodeFileTypeFilter.getGcodeFileChooser(\n            settings.getLastOpenedFilename());\n\n        int returnVal = fileChooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File gcodeFile = fileChooser.getSelectedFile();\n\n            // Save the new directory!\n            settings.setLastOpenedFilename(gcodeFile.getParent());\n\n            addFileToWorkflow(gcodeFile);\n        }  \n    }                                         \n\n    private void removeButtonActionPerformed(ActionEvent evt) {                                             \n        int[] selectedRows = fileTable.getSelectedRows();\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n        for (int i = selectedRows.length - 1; i >= 0; i--) {\n            int row = selectedRows[i]\n            this.model.removeRow(row);\n            this.model.fireTableRowsDeleted(row, row);\n        }\n    }                                            \n\n\n\n\nUp / Down Button Action Handlers\n\n\n\n\nThe up and down action buttons are pure java code. They don't do anything\n  you wouldn't do with any other Swing application. The code here deals strictly\n  with moving selections around. Although a little tricky, and not totally\n  relevant to UGS, they are included because the feature wouldn't be complete\n  without them.\n\n\n\n\n    private void upButtonActionPerformed(ActionEvent evt) {                                         \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[0] == 0) return;\n\n        for (int i = 0; i < selectedRows.length; i++) {\n            selectedRows[i] = this.moveRow(selectedRows[i], -1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    }                                        \n\n    private void downButtonActionPerformed(ActionEvent evt) {                                           \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[selectedRows.length-1]\n                == fileTable.getRowCount()) return;\n\n        for (int i = selectedRows.length - 1; i >= 0; i--) {\n            selectedRows[i] = this.moveRow(selectedRows[i], 1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    } \n\n\n\n\nNetBeans Platform Component Lifecycle Code\n\n\n\n\nOf the automatically generated methods, \ncomponentOpened\n is the only one\n  which needed some custom code. In case the component had been closed earlier\n  or wasn't loaded until after a file stream started, grab the \nwasSending\n\n  state and save it for later.\n\n\n\n\n    @Override\n    public void componentOpened() {\n        this.wasSending = backend.isSending();\n    }\n\n    @Override\n    public void componentClosed() {\n        // No special close handling.\n    }\n\n    void writeProperties(java.util.Properties p) {\n        // better to version settings since initial version as advocated at\n        // http://wiki.apidesign.org/wiki/PropertyFiles\n        p.setProperty(\"version\", \"1.0\");\n\n        // We could save the loaded files here\n    }\n\n    void readProperties(java.util.Properties p) {\n        String version = p.getProperty(\"version\");\n\n        // We could load previously loaded files here\n    }\n\n\n\n\nHelper Methods\n\n\n\n\nFinally, here are the helper methods used above.\n\n\n\n\n    /**\n     * Look for the provided file in the file table.\n     */\n    private int findFileIndex(File gcodeFile) {\n        if (gcodeFile == null) return -1;\n\n        for (int i = 0; i < model.getRowCount(); i++) {\n            String file = (String) model.getValueAt(i, 0);\n            if (file != null && gcodeFile.getAbsolutePath().equals(file)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Move a given row by some offset. If the offset would move the row outside\n     * of the current table size, the row is not moved.\n     */\n    private int moveRow(int row, int offset) {\n        int dest = row + offset;\n        if (dest < 0 || dest >= model.getRowCount()) {\n            return row;\n        }\n\n        model.moveRow(row, row, dest);\n        return dest;\n    }\n\n\n\n\nConclusion\n\n\nHere is a quick screencast of what this plugin does for us. In the GUI builder I swapped in some up/down arrows compared to the tutorial.",
            "title": "Plugin"
        },
        {
            "location": "/dev/plugin/#note-the-ugs-platform-has-been-updated-to-use-maven-some-parts-of-this-document-need-to-be-updated-to-reflect-that-change",
            "text": "",
            "title": "Note: The UGS Platform has been updated to use maven. Some parts of this document need to be updated to reflect that change."
        },
        {
            "location": "/dev/plugin/#plugin-development",
            "text": "The UGS Platform is built ontop of the NetBeans Platform. This gives us powerful\ntools to work with, including a robust plugin system. The heart of the UGS\nPlatform is a module which wraps and exposes the Universal Gcode Sender JAR\nfile - the same jar you could execute to run the Classic GUI! Other than using\nthe UGSLib module, developing a plugin for the UGS Platform is exactly the same\nas developing any other NetBeans Platform plugin. And there is lots of great\ndocumentation for that, here is the  NetBeans Platform Plugin Quick Start \nguide.",
            "title": "Plugin development"
        },
        {
            "location": "/dev/plugin/#workflow-plugin-tutorial",
            "text": "In this tutorial we're going to build a window to help manage jobs that use\nmultiple tools which are split into multiple files. The rough design idea will\nhave a central table with four columns containing:  File name  Tool name (editable)\n* Finished flag  There will be a pair of buttons to add and remove files from the table, and\nwe will also hook up a UGS event listener to detect when files are opened from\nother areas of the interface as well.  Lastly, we'll add another pair of buttons to move rows around in the table, so\nthat we can reorganize the workflow if files were added out of order the order.  Here is a sketch of what we're building:",
            "title": "Workflow Plugin Tutorial"
        },
        {
            "location": "/dev/plugin/#create-and-configure-project",
            "text": "Universal Gcode Sender is developed with NetBeans, and plugins are no exception.\nOnce you've cloned the Universal Gcode Sender project you should be able to open\nthe UGSPlatform folder with NetBeans and it will discover a project that you can open.\nTo start building your module expand the UGSPlatform section, right-click the\nmodules directory and select  Add New... .   This will open up a wizard where you name the module, and declare the source\npath. For this example the module is named WorkflowModuleTutorial and the source\npath is com.willwinder.ugs.nbp.workflowmoduletutorial which is the convention\nused in the core modules.",
            "title": "Create and configure project"
        },
        {
            "location": "/dev/plugin/#add-ugs-dependencies",
            "text": "Your module should now be listed in the Modules section. If it doesn't you may\nneed to restart NetBeans. Before we dive into the code there are a couple helper\nclasses to import which will give you full access to the UGS API. Double click\nyour module from the Modules section to open the code, then right-click the top\nlevel item which appeared and select the properties menu.  Select  Add Dependency... , here you should search for  UGSLib  and CentralLookup  then add them to your plugin.",
            "title": "Add UGS dependencies"
        },
        {
            "location": "/dev/plugin/#create-window-class",
            "text": "Now we're ready to build the module. In this tutorial we're building a window\nto manage a multi-job workflow, so we'll start by adding a window to customize.   Open the new module and right click the new package, in the context menu go to New  ->  Window... . To bring up the new window wizard.  In the first screen of the wizard choose the default location your window\nwill appear. Custom locations have been designed for UGS Platform, the largest\nis named  visualizer  because it is the Visualizer's default location. We'll\nuse this location for our plugin.  This means that when our plugin opens it will\nbe tabbed with the Visualizer module.  Click next and choose a class name for your module, for this tutorial I'm\ngoing to call it  WorkflowModuleTutorial .",
            "title": "Create window class"
        },
        {
            "location": "/dev/plugin/#build-the-gui",
            "text": "The NetBeans GUI builder makes it easy to make a custom user interface without\nwriting a single line of code (which is the main reason UGS uses NetBeans!).\nUsing the GUI builder we'll add some buttons and a table. This step can be as\nelaborate as you want. If you're a seasoned swing developer and prefer not to\nuse the magic GUI builder, no worries, you can create the UI programatically as\nwell - but that is a different tutorial.   Take a look at the screenshot below. The  [TopComponent] - Navigator - Editor \n  window shows all the objects that have been added with the GUI builder.  There are four JButtons, a JTable nested inside a JScrollPane and a JPanel\n  which I used to make alignment a little easier (The GUI Builder is powerful,\n  but it can also be a bit quirky).  Putting the JTable inside a JScrollPane makes it so that if too many items\n  get added to the table it will scroll rather than dissapear off the bottom.  Note:  The name given to these components will be used in the code, so\n  be sure to use the names shown in the screenshot.    The JTable is going to be the trickiest part of build the GUI. To configure the\ntable right-click the JTable object from the component navigator and select Table Contents... . Here you can add our 3 columns and specify that the data\ntypes. You can also specify which columns are editable, in this example we want\nthe user to be able to type in what type of tool should be used.",
            "title": "Build the GUI"
        },
        {
            "location": "/dev/plugin/#autogenerated-code",
            "text": "Before writing any code, lets take a look at what has already been automatically\ngenerated for us.    Just above the class there are a number of annotations. These are used by\n   the NetBeans platform, most of them were setup according to how you filled\n   in the Wizards earlier. They can also configure things like keyboard\n   shortcuts, and where things are put in the dropdown menus.    Within the class there are several grayed out sections. This is code\n   generated by NetBeans which the IDE prevents you from modifying outside the\n   GUI builder or in some cases component properties. For example if you wanted\n   to use a custom JTable, you would configure the table in the GUI builder by\n   adding a custom constructor.    At the end of the file is  componentOpened  and  componentClosed , these are\n   lifecycle events that are called when the window has been opened or closed.    Also at the end of the file is  writeProperties  and  readProperties , these\n   are used to save the window state between runs.",
            "title": "Autogenerated code"
        },
        {
            "location": "/dev/plugin/#annotated-code",
            "text": "This is the longest section because it will explain every line of code added to\nthe  WorkflowModuleTutorial  class. The most complicated code deals with Swing\ncomponent manipulation, with just a smattering of UGS lifecycle events to push\nthings along.",
            "title": "Annotated code"
        },
        {
            "location": "/dev/plugin/#class-signature",
            "text": "First there are a few class state object we'll need and two Listeners we'll\n  be implementing.   /**\n * UGSEventListener - this is how a plugin can listen to UGS lifecycle events.\n * ListSelectionListener - listen for table selections.\n */\npublic final class WorkflowWindowTutorialTopComponent\n        extends TopComponent\n        implements UGSEventListener, ListSelectionListener {\n\n    // These are the UGS backend objects for interacting with the backend.\n    private final Settings settings;\n    private final BackendAPI backend;\n\n    // This is used to identify when a stream has completed.\n    private boolean wasSending;\n\n    // This is used in most methods, so cache it here.\n    DefaultTableModel model;",
            "title": "Class signature"
        },
        {
            "location": "/dev/plugin/#constructor",
            "text": "In the constructor we register the class with the UGS backend and also set\n  the class as a listener to table selection events.       public WorkflowWindowTopComponent() {\n        initComponents();\n        setName(Bundle.CTL_WorkflowWindowTopComponent());\n        setToolTipText(Bundle.HINT_WorkflowWindowTopComponent());\n\n        // This is how to access the UGS backend and register the listener.\n        // CentralLookup is used to get singleton instances of the UGS\n        // Settings and BackendAPI objects.\n        settings = CentralLookup.getDefault().lookup(Settings.class);\n        backend = CentralLookup.getDefault().lookup(BackendAPI.class);\n        backend.addUGSEventListener(this);\n\n        // Allow contiguous ranges of selections and register a listener.\n        this.fileTable.setSelectionMode(\n            ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n        ListSelectionModel cellSelectionModel =\n            this.fileTable.getSelectionModel();\n        cellSelectionModel.addListSelectionListener(this);\n\n        // Cache the model object.\n        model = (DefaultTableModel)this.fileTable.getModel();\n    }",
            "title": "Constructor"
        },
        {
            "location": "/dev/plugin/#ugs-event-listener",
            "text": "This is the event sent from the UGS Backend, when a file is loaded or the\n  state changes a notification will be sent.  If the state switches from  COMM_SENDING  to  COMM_IDLE  we'll run a\n   completeFile  method.  If a file is loaded, we add it to the table.       @Override\n    public void UGSEvent(UGSEvent cse) {\n        if (cse.isStateChangeEvent()) {\n            if (wasSending && cse.getControlState() == ControlState.COMM_IDLE)\n               this.completeFile(backend.getGcodeFile());\n            wasSending = backend.isSending();\n        }\n        if (cse.isFileChangeEvent()) {\n            this.addFileToWorkflow(backend.getGcodeFile());\n        }\n\n    }",
            "title": "UGS Event Listener"
        },
        {
            "location": "/dev/plugin/#file-complete-handler",
            "text": "When a command is complete we'll update the JTable, select the next file that\n  needs to be sent and popup a notification informing the user what they should\n  do next. The selection event will be sent and handled in the selection\n  handler.       public void completeFile(File gcodeFile) {\n        if (gcodeFile == null) return;\n\n        // Make sure the file is loaded in the table.\n        int fileIndex = findFileIndex(gcodeFile);\n        if (fileIndex < 0) return;\n\n        // Mark that it has been completed.\n        model.setValueAt(true, fileIndex, 2);\n\n        fileIndex++;\n        String message;\n\n        // Make sure there is another command left.\n        if (fileIndex < fileTable.getRowCount()) {\n            String nextTool = (String) model.getValueAt(fileIndex, 1);\n            String messageTemplate =\n                   \"Finished sending '%s'.\\n\"\n                 + \"The next file uses tool '%s'\\n\"\n                 + \"Load tool and move machine to its zero location\\n\"\n                 + \"and click send to continue this workflow.\";\n            message = String.format(\n                messageTemplate, gcodeFile.getName(), nextTool);\n\n            // Select the next row, this will trigger a selection event.\n            fileTable.setRowSelectionInterval(fileIndex, fileIndex);\n\n        // Use a different message if we're finished.\n        } else {\n            message = \"Finished sending the last file!\";\n        }\n\n        // Display a notification.\n        java.awt.EventQueue.invokeLater(() -> {\n            JOptionPane.showMessageDialog(new JFrame(), message, \n                    \"Workflow Event\", JOptionPane.PLAIN_MESSAGE);\n        });\n    }",
            "title": "File Complete Handler"
        },
        {
            "location": "/dev/plugin/#jtable-selection-listener",
            "text": "This is the selection listener, when a file is selected load it in the backend.       @Override\n    public void valueChanged(ListSelectionEvent e) {\n        int[] selectedRow = fileTable.getSelectedRows();\n        // Only load files when there is a single selection.\n        if (selectedRow.length == 1) {\n            // Pull the file out of the table and set it in the backend.\n            String file = (String) model.getValueAt(selectedRow[0], 0);\n            try {\n                backend.setGcodeFile(new File(file));\n            } catch (Exception ex) {\n                Exceptions.printStackTrace(ex);\n            }\n        }\n    }",
            "title": "JTable Selection Listener"
        },
        {
            "location": "/dev/plugin/#jtable-helper",
            "text": "Helper method to add a file to the JTable, first making sure that it isn't\n  already in the table.       public void addFileToWorkflow(File gcodeFile) {\n        if (gcodeFile == null) {\n            return;\n        }\n\n        int fileIndex = findFileIndex(gcodeFile);\n        // Don't re-add a file.\n        if (fileIndex >= 0) {\n            return;\n        }\n\n        model.addRow(new Object[]{\n                gcodeFile.getAbsolutePath(),\n                \"default\",\n                false\n            });\n\n        // Fire off the selection event to load the file.\n        int lastRow = fileTable.getRowCount() - 1;\n        fileTable.setRowSelectionInterval(lastRow, lastRow);\n    }",
            "title": "JTable Helper"
        },
        {
            "location": "/dev/plugin/#addremove-button-action-handlers",
            "text": "Now we implement the button event methods. They are generated by double\n  clicking the buttons in the GUI Builder. This generates the swing code that\n  attaches the  ActionPerformed  events to the button click callbacks.  addButtonActionPerformed  simply displays a file chooser (using some UGS\n  library built ins) and calls the  addFileToWorkflow  method defined earlier.  removeButtonActoinPerformed  is even simpler, it uses standard JTable\n  functionality to remove any selected rows. The only thing clever here is that\n  rows are removed starting from the end to avoid having the index of later\n  selections change while deleting rows one at a time.       private void addButtonActionPerformed(ActionEvent evt) {                                          \n        // Open a file chooser pointing at the last opened directory.\n        JFileChooser fileChooser = GcodeFileTypeFilter.getGcodeFileChooser(\n            settings.getLastOpenedFilename());\n\n        int returnVal = fileChooser.showOpenDialog(this);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            File gcodeFile = fileChooser.getSelectedFile();\n\n            // Save the new directory!\n            settings.setLastOpenedFilename(gcodeFile.getParent());\n\n            addFileToWorkflow(gcodeFile);\n        }  \n    }                                         \n\n    private void removeButtonActionPerformed(ActionEvent evt) {                                             \n        int[] selectedRows = fileTable.getSelectedRows();\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n        for (int i = selectedRows.length - 1; i >= 0; i--) {\n            int row = selectedRows[i]\n            this.model.removeRow(row);\n            this.model.fireTableRowsDeleted(row, row);\n        }\n    }",
            "title": "Add/Remove Button Action Handlers"
        },
        {
            "location": "/dev/plugin/#up-down-button-action-handlers",
            "text": "The up and down action buttons are pure java code. They don't do anything\n  you wouldn't do with any other Swing application. The code here deals strictly\n  with moving selections around. Although a little tricky, and not totally\n  relevant to UGS, they are included because the feature wouldn't be complete\n  without them.       private void upButtonActionPerformed(ActionEvent evt) {                                         \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[0] == 0) return;\n\n        for (int i = 0; i < selectedRows.length; i++) {\n            selectedRows[i] = this.moveRow(selectedRows[i], -1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    }                                        \n\n    private void downButtonActionPerformed(ActionEvent evt) {                                           \n        int[] selectedRows = fileTable.getSelectedRows();\n\n        // Exit early if nothing is selected.\n        if (selectedRows.length == 0) return;\n\n        Arrays.sort(selectedRows);\n\n        // Exit early if the selected range can't move.\n        if (selectedRows[selectedRows.length-1]\n                == fileTable.getRowCount()) return;\n\n        for (int i = selectedRows.length - 1; i >= 0; i--) {\n            selectedRows[i] = this.moveRow(selectedRows[i], 1);\n        }\n\n        int first = selectedRows[0];\n        int last = selectedRows[selectedRows.length-1];\n        fileTable.setRowSelectionInterval(first, last);\n    }",
            "title": "Up / Down Button Action Handlers"
        },
        {
            "location": "/dev/plugin/#netbeans-platform-component-lifecycle-code",
            "text": "Of the automatically generated methods,  componentOpened  is the only one\n  which needed some custom code. In case the component had been closed earlier\n  or wasn't loaded until after a file stream started, grab the  wasSending \n  state and save it for later.       @Override\n    public void componentOpened() {\n        this.wasSending = backend.isSending();\n    }\n\n    @Override\n    public void componentClosed() {\n        // No special close handling.\n    }\n\n    void writeProperties(java.util.Properties p) {\n        // better to version settings since initial version as advocated at\n        // http://wiki.apidesign.org/wiki/PropertyFiles\n        p.setProperty(\"version\", \"1.0\");\n\n        // We could save the loaded files here\n    }\n\n    void readProperties(java.util.Properties p) {\n        String version = p.getProperty(\"version\");\n\n        // We could load previously loaded files here\n    }",
            "title": "NetBeans Platform Component Lifecycle Code"
        },
        {
            "location": "/dev/plugin/#helper-methods",
            "text": "Finally, here are the helper methods used above.       /**\n     * Look for the provided file in the file table.\n     */\n    private int findFileIndex(File gcodeFile) {\n        if (gcodeFile == null) return -1;\n\n        for (int i = 0; i < model.getRowCount(); i++) {\n            String file = (String) model.getValueAt(i, 0);\n            if (file != null && gcodeFile.getAbsolutePath().equals(file)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Move a given row by some offset. If the offset would move the row outside\n     * of the current table size, the row is not moved.\n     */\n    private int moveRow(int row, int offset) {\n        int dest = row + offset;\n        if (dest < 0 || dest >= model.getRowCount()) {\n            return row;\n        }\n\n        model.moveRow(row, row, dest);\n        return dest;\n    }",
            "title": "Helper Methods"
        },
        {
            "location": "/dev/plugin/#conclusion",
            "text": "Here is a quick screencast of what this plugin does for us. In the GUI builder I swapped in some up/down arrows compared to the tutorial.",
            "title": "Conclusion"
        },
        {
            "location": "/dev/gcode_processor/",
            "text": "Gcode Processor Development\n\n\nThe UGS core library has a flexible gcode processor plugin system. It is designed\nas a processing pipeline to convert one line of code at a time by passing it\nthrough multiple \nCommand Processor\n plugins. Some advanced features in UGS,\nlike the Auto Leveler, take advantage of this feature to inject a special\nprocessor module into the gcode processing pipeline. Other processors are simpler,\nsuch as the \nM30Processor\n which simply removes unwanted \nM30\n commands, or the\n\nCommandLengthProcessor\n which causes an error if the final processed line has\ntoo much data for your controller.\n\n\nThis process is configured using a JSON file which holds processor configuration,\norder in which processors should appear in the pipeline, and whether or not they\nare enabled. All of this is configurable in UGS and UGP in a \nGcode Processor\nConfiguration\n menu.\n\n\nAnatomy of a CommandProcessor\n\n\nThe processor interface is simple. One command goes in along with the current state\nand a list of output commands come out. A CommandProcessor might discover invalid\ninput, in which case a GcodeParserException can be thrown for the GcodeParser to\nhandle.\n\n\npublic interface CommandProcessor {\n    /**\n     * Given a command and the current state of a program returns a replacement\n     * list of commands.\n     * @param command Input gcode.\n     * @param state State of the gcode parser when the command will run.\n     * @return One or more gcode commands to replace the original command with.\n     */\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException;\n\n    /**\n     * Returns information about the current command and its configuration.\n     * @return \n     */\n    public String getHelp();\n}\n\n\n\n\nSimple Example\n\n\nThe \nCommandLengthProcessor\n is one of the simplest examples of a\nCommandProcessor.  One thing of interest is that it accepts a length parameter\nduring configuration. By adding a CommandLengthProcessor to the GcodeParser,\nyou can ensure the maximum length of commands.\n\n\npublic class CommandLengthProcessor implements CommandProcessor {\n    final private int length;\n    public CommandLengthProcessor(int length) {\n        this.length = length;\n    }\n\n    @Override\n    public String getHelp() {\n        // Global localization helpers are used for the help message.\n        return Localization.getString(\"sender.help.command.length\") + \"\\n\" +\n                Localization.getString(\"sender.command.length\")\n                + \": \" + length;\n    }\n\n    @Override\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException {\n        if (command.length() > length)\n            throw new GcodeParserException(\"Command '\" + command + \"' is longer than \" + length + \" characters.\");\n\n        return Collections.singletonList(command);\n    }\n}\n\n\n\n\nMore Complex Examples\n\n\nThe following examples can be found in GitHub, they wont have the full code\nincluded.\n\n\nDecimalProcessor\n\n\nThis is only slightly more complicated than the CommandLengthProcessor. It adds\nin some config validation by throwing a RuntimeException in the constructor,\nwhich is handled by code which configures the GcodeParser. The \nprocessCommand\n\nmethod is then able to truncate any decimals using simple string manipulation.\n\n\nFeedOverrideProcessor\n\n\nLike the \nDecimalProcessor\n, the \nFeedOverrideProcessor\n is able to modifie any\n\nF-Commands\n with simple string manipulation.\n\n\nLineSplitter\n\n\nThe \nLineSplitter\n CommandProcessor will actually modify commands by parsing\nthe gcode and rewriting it. There are several utilities used here to help:\n\n\n\n\nGcodeParser.processCommand\n - Converts the command string into something\neasier to work with.\n\n\nGcodePreprocessorUtils.extractMotion\n - Helper to extract all words associated\nto movement commands, the remainder should still be sent but may not be sent in\nthe context of the rewritten command.\n\n\n\n\nThe remaining logic checks the length of any \nG0\n or \nG1\n commands and converts\nthem, or returns the original command unmodified.\n\n\nTutorial: Creating a New CommandProcessor\n\n\nCreating a fully integrated and configurable \nCommandProcessor\n is simple, but\ndoes touch a number of different files. This tutorial will go over those pieces\nin the context of creating a processor named \nM3Dweller\n.\n\n\nGoal\n\n\nCreate a processor which inserts a \nDwell\n command (short delay) whenever the\nspindle is enabled. This allows any potentially slow setups such as VFD's to\ncome up to speed. It should be configurable via the \nGcode Processor\nConfiguration\n menu.\n\n\nCreating the processor\n\n\nFirst you'll notice that the constructor initializes the command which should\nbe added after our spindle start \nM3\n command. The locale is set to make sure\ncomma is not used as a decimal separator:\n\n\n    private final String dwellCommand;\n\n    public M3Dweller(double dwellDuration) {\n        this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration);\n    }\n\n\n\n\nThe help method simply adds some comments for the settings GUI:\n\n\n    @Override\n    public String getHelp() {\n        return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\";\n    }\n\n\n\n\nEverything is then pulled together in the \nprocessCommand\n method to return an\nextra dwell command when \nM3\n is detected:\n\n\n    // Contains an M3 not followed by another digit (i.e. M30)\n    Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\");\n\n    @Override\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException {\n        if (m3Pattern.matcher(command).matches()) {\n            return Arrays.asList(command, dwellCommand);\n        }\n        return Collections.singletonList(command);\n    }\n\n\n\n\nAll at once now:\n\n\npublic class M3Dweller implements CommandProcessor {\n    private final String dwellCommand;\n\n    // Contains an M3 not followed by another digit (i.e. M30)\n    Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\");\n\n    public M3Dweller(double dwellDuration) {\n        this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration);\n    }\n\n    @Override\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException {\n        String noComments = GcodePreprocessorUtils.removeComment(command);\n        if (m3Pattern.matcher(noComments).matches()) {\n            return Arrays.asList(command, dwellCommand);\n        }\n        return Collections.singletonList(command);\n    }\n\n    @Override\n    public String getHelp() {\n        return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\";\n    }\n}\n\n\n\n\nHooking up the JSON\n\n\nThe json files are stored in \nugs-core/src/resources/firmware_config\n, each of\nthese will be updated to include our new processor. Notice that we have an\nargument named duration, and that it is disabled by default:\n\n\n                \"name\": \"M3Dweller\",\n                \"enabled\": false,\n                \"optional\": true,\n                \"args\": {\n                    \"duration\": 2.5\n                }\n            },{\n\n\n\n\nWe also increment the version string, which will prompt users that there is a\nnew configuration file available and they may need to revisit their settings:\n\n\n-    \"Version\": 3,\n+    \"Version\": 4,\n\n\n\n\nJSON Loader\n\n\nThe last step is to update the \nCommandProcessorLoader\n to include logic that\ncreates the new M3Dweller when needed. I used one of the other processors as an\nexample and made sure to make a corresponding entry for the \nM3Dweller\n in each\nof the corresponding code and comment locations:\n\n\n                case \"M3Dweller\":\n                    double duration = pc.args.get(\"duration\").getAsDouble();\n                    p = new M3Dweller(duration);\n                    break;\n\n\n\n\nThere is also a test which should be updated to make sure everything is working:\n\n\n+        args = new JsonObject();\n+        args.addProperty(\"duration\", 2.5);\n+        object = new JsonObject();\n+        object.addProperty(\"name\", \"M3Dweller\");\n+        object.add(\"args\", args);\n+        array.add(object);\n+\n         String jsonConfig = array.toString();\n         List<CommandProcessor> processors = CommandProcessorLoader.initializeWithProcessors(jsonConfig);\n\n-        assertEquals(8, processors.size());\n+        assertEquals(9, processors.size());\n         assertEquals(ArcExpander.class, processors.get(0).getClass());\n         assertEquals(CommentProcessor.class, processors.get(1).getClass());\n         assertEquals(DecimalProcessor.class, processors.get(2).getClass());\n         assertEquals(FeedOverrideProcessor.class, processors.get(3).getClass());\n         assertEquals(M30Processor.class, processors.get(4).getClass());\n         assertEquals(PatternRemover.class, processors.get(5).getClass());\n         assertEquals(CommandLengthProcessor.class, processors.get(6).getClass());\n         assertEquals(WhitespaceProcessor.class, processors.get(7).getClass());\n+        assertEquals(M3Dweller.class, processors.get(8).getClass());\n\n\n\n\nTesting\n\n\nThe command processors lend themselves to thorough testing, so we create a new\n\nM3DwellerTest.java\n file in the associated test package and write some tests:\n\n\n    @Test\n    public void testReplaces() throws Exception {\n        M3Dweller dweller = new M3Dweller(2.5);\n        String command;\n\n        command = \"M3\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"m3\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"M3 S1000\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"m3 S1000\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"(this is ignored) M3 S1000\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n    }\n\n    @Test\n    public void testNoOp() throws Exception {\n        M3Dweller dweller = new M3Dweller(2.5);\n        String command;\n        command = \"anything else\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command);\n\n        command = \"M30\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command);\n\n        command = \"G0 X0 Y0 (definitely not ready to start the spindle with an M3 yet)\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command);\n    }\n\n\n\n\nLocalizing\n\n\nIn addition to the help message which may use the global \nLocalization\n helper,\nthe settings menu will attempt to find something with the same name as in the\nJSON file. So we add an entry to \n\n./ugs-core/src/resources/MessagesBundle_en_US.properties\n, which will later be\npulled into a separate localization service to be localized in other languages.\n\n\n WhitespaceProcessor = Whitespace Remover\n+M3Dweller = Spindle start delay\n controller.exception.smoothie.booting = Smoothie has not finished booting.\n\n\n\n\nConclusion\n\n\nWe have now fully integrated our \nM3Dweller\n processor into the UGS framework\nand users of UGS and UGP can both make use of it.\n\n\nThe raw commit for this feature is found on \ngithub here\n.",
            "title": "Gcode Processors"
        },
        {
            "location": "/dev/gcode_processor/#gcode-processor-development",
            "text": "The UGS core library has a flexible gcode processor plugin system. It is designed\nas a processing pipeline to convert one line of code at a time by passing it\nthrough multiple  Command Processor  plugins. Some advanced features in UGS,\nlike the Auto Leveler, take advantage of this feature to inject a special\nprocessor module into the gcode processing pipeline. Other processors are simpler,\nsuch as the  M30Processor  which simply removes unwanted  M30  commands, or the CommandLengthProcessor  which causes an error if the final processed line has\ntoo much data for your controller.  This process is configured using a JSON file which holds processor configuration,\norder in which processors should appear in the pipeline, and whether or not they\nare enabled. All of this is configurable in UGS and UGP in a  Gcode Processor\nConfiguration  menu.",
            "title": "Gcode Processor Development"
        },
        {
            "location": "/dev/gcode_processor/#anatomy-of-a-commandprocessor",
            "text": "The processor interface is simple. One command goes in along with the current state\nand a list of output commands come out. A CommandProcessor might discover invalid\ninput, in which case a GcodeParserException can be thrown for the GcodeParser to\nhandle.  public interface CommandProcessor {\n    /**\n     * Given a command and the current state of a program returns a replacement\n     * list of commands.\n     * @param command Input gcode.\n     * @param state State of the gcode parser when the command will run.\n     * @return One or more gcode commands to replace the original command with.\n     */\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException;\n\n    /**\n     * Returns information about the current command and its configuration.\n     * @return \n     */\n    public String getHelp();\n}",
            "title": "Anatomy of a CommandProcessor"
        },
        {
            "location": "/dev/gcode_processor/#simple-example",
            "text": "The  CommandLengthProcessor  is one of the simplest examples of a\nCommandProcessor.  One thing of interest is that it accepts a length parameter\nduring configuration. By adding a CommandLengthProcessor to the GcodeParser,\nyou can ensure the maximum length of commands.  public class CommandLengthProcessor implements CommandProcessor {\n    final private int length;\n    public CommandLengthProcessor(int length) {\n        this.length = length;\n    }\n\n    @Override\n    public String getHelp() {\n        // Global localization helpers are used for the help message.\n        return Localization.getString(\"sender.help.command.length\") + \"\\n\" +\n                Localization.getString(\"sender.command.length\")\n                + \": \" + length;\n    }\n\n    @Override\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException {\n        if (command.length() > length)\n            throw new GcodeParserException(\"Command '\" + command + \"' is longer than \" + length + \" characters.\");\n\n        return Collections.singletonList(command);\n    }\n}",
            "title": "Simple Example"
        },
        {
            "location": "/dev/gcode_processor/#more-complex-examples",
            "text": "The following examples can be found in GitHub, they wont have the full code\nincluded.",
            "title": "More Complex Examples"
        },
        {
            "location": "/dev/gcode_processor/#decimalprocessor",
            "text": "This is only slightly more complicated than the CommandLengthProcessor. It adds\nin some config validation by throwing a RuntimeException in the constructor,\nwhich is handled by code which configures the GcodeParser. The  processCommand \nmethod is then able to truncate any decimals using simple string manipulation.",
            "title": "DecimalProcessor"
        },
        {
            "location": "/dev/gcode_processor/#feedoverrideprocessor",
            "text": "Like the  DecimalProcessor , the  FeedOverrideProcessor  is able to modifie any F-Commands  with simple string manipulation.",
            "title": "FeedOverrideProcessor"
        },
        {
            "location": "/dev/gcode_processor/#linesplitter",
            "text": "The  LineSplitter  CommandProcessor will actually modify commands by parsing\nthe gcode and rewriting it. There are several utilities used here to help:   GcodeParser.processCommand  - Converts the command string into something\neasier to work with.  GcodePreprocessorUtils.extractMotion  - Helper to extract all words associated\nto movement commands, the remainder should still be sent but may not be sent in\nthe context of the rewritten command.   The remaining logic checks the length of any  G0  or  G1  commands and converts\nthem, or returns the original command unmodified.",
            "title": "LineSplitter"
        },
        {
            "location": "/dev/gcode_processor/#tutorial-creating-a-new-commandprocessor",
            "text": "Creating a fully integrated and configurable  CommandProcessor  is simple, but\ndoes touch a number of different files. This tutorial will go over those pieces\nin the context of creating a processor named  M3Dweller .",
            "title": "Tutorial: Creating a New CommandProcessor"
        },
        {
            "location": "/dev/gcode_processor/#goal",
            "text": "Create a processor which inserts a  Dwell  command (short delay) whenever the\nspindle is enabled. This allows any potentially slow setups such as VFD's to\ncome up to speed. It should be configurable via the  Gcode Processor\nConfiguration  menu.",
            "title": "Goal"
        },
        {
            "location": "/dev/gcode_processor/#creating-the-processor",
            "text": "First you'll notice that the constructor initializes the command which should\nbe added after our spindle start  M3  command. The locale is set to make sure\ncomma is not used as a decimal separator:      private final String dwellCommand;\n\n    public M3Dweller(double dwellDuration) {\n        this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration);\n    }  The help method simply adds some comments for the settings GUI:      @Override\n    public String getHelp() {\n        return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\";\n    }  Everything is then pulled together in the  processCommand  method to return an\nextra dwell command when  M3  is detected:      // Contains an M3 not followed by another digit (i.e. M30)\n    Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\");\n\n    @Override\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException {\n        if (m3Pattern.matcher(command).matches()) {\n            return Arrays.asList(command, dwellCommand);\n        }\n        return Collections.singletonList(command);\n    }  All at once now:  public class M3Dweller implements CommandProcessor {\n    private final String dwellCommand;\n\n    // Contains an M3 not followed by another digit (i.e. M30)\n    Pattern m3Pattern = Pattern.compile(\".*[mM]3(?!\\\\d)(\\\\D.*)?\");\n\n    public M3Dweller(double dwellDuration) {\n        this.dwellCommand = String.format(Locale.ROOT, \"G4P%.2f\", dwellDuration);\n    }\n\n    @Override\n    public List<String> processCommand(String command, GcodeState state) throws GcodeParserException {\n        String noComments = GcodePreprocessorUtils.removeComment(command);\n        if (m3Pattern.matcher(noComments).matches()) {\n            return Arrays.asList(command, dwellCommand);\n        }\n        return Collections.singletonList(command);\n    }\n\n    @Override\n    public String getHelp() {\n        return \"Add a delay after enabling the spindle with \\\"M3\\\" commands. \\\"M3\\\" must be the only command on the line.\";\n    }\n}",
            "title": "Creating the processor"
        },
        {
            "location": "/dev/gcode_processor/#hooking-up-the-json",
            "text": "The json files are stored in  ugs-core/src/resources/firmware_config , each of\nthese will be updated to include our new processor. Notice that we have an\nargument named duration, and that it is disabled by default:                  \"name\": \"M3Dweller\",\n                \"enabled\": false,\n                \"optional\": true,\n                \"args\": {\n                    \"duration\": 2.5\n                }\n            },{  We also increment the version string, which will prompt users that there is a\nnew configuration file available and they may need to revisit their settings:  -    \"Version\": 3,\n+    \"Version\": 4,",
            "title": "Hooking up the JSON"
        },
        {
            "location": "/dev/gcode_processor/#json-loader",
            "text": "The last step is to update the  CommandProcessorLoader  to include logic that\ncreates the new M3Dweller when needed. I used one of the other processors as an\nexample and made sure to make a corresponding entry for the  M3Dweller  in each\nof the corresponding code and comment locations:                  case \"M3Dweller\":\n                    double duration = pc.args.get(\"duration\").getAsDouble();\n                    p = new M3Dweller(duration);\n                    break;  There is also a test which should be updated to make sure everything is working:  +        args = new JsonObject();\n+        args.addProperty(\"duration\", 2.5);\n+        object = new JsonObject();\n+        object.addProperty(\"name\", \"M3Dweller\");\n+        object.add(\"args\", args);\n+        array.add(object);\n+\n         String jsonConfig = array.toString();\n         List<CommandProcessor> processors = CommandProcessorLoader.initializeWithProcessors(jsonConfig);\n\n-        assertEquals(8, processors.size());\n+        assertEquals(9, processors.size());\n         assertEquals(ArcExpander.class, processors.get(0).getClass());\n         assertEquals(CommentProcessor.class, processors.get(1).getClass());\n         assertEquals(DecimalProcessor.class, processors.get(2).getClass());\n         assertEquals(FeedOverrideProcessor.class, processors.get(3).getClass());\n         assertEquals(M30Processor.class, processors.get(4).getClass());\n         assertEquals(PatternRemover.class, processors.get(5).getClass());\n         assertEquals(CommandLengthProcessor.class, processors.get(6).getClass());\n         assertEquals(WhitespaceProcessor.class, processors.get(7).getClass());\n+        assertEquals(M3Dweller.class, processors.get(8).getClass());",
            "title": "JSON Loader"
        },
        {
            "location": "/dev/gcode_processor/#testing",
            "text": "The command processors lend themselves to thorough testing, so we create a new M3DwellerTest.java  file in the associated test package and write some tests:      @Test\n    public void testReplaces() throws Exception {\n        M3Dweller dweller = new M3Dweller(2.5);\n        String command;\n\n        command = \"M3\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"m3\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"M3 S1000\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"m3 S1000\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n\n        command = \"(this is ignored) M3 S1000\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command,\"G4P2.50\");\n    }\n\n    @Test\n    public void testNoOp() throws Exception {\n        M3Dweller dweller = new M3Dweller(2.5);\n        String command;\n        command = \"anything else\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command);\n\n        command = \"M30\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command);\n\n        command = \"G0 X0 Y0 (definitely not ready to start the spindle with an M3 yet)\";\n        Assertions.assertThat(dweller.processCommand(command, null)).containsExactly(command);\n    }",
            "title": "Testing"
        },
        {
            "location": "/dev/gcode_processor/#localizing",
            "text": "In addition to the help message which may use the global  Localization  helper,\nthe settings menu will attempt to find something with the same name as in the\nJSON file. So we add an entry to  ./ugs-core/src/resources/MessagesBundle_en_US.properties , which will later be\npulled into a separate localization service to be localized in other languages.   WhitespaceProcessor = Whitespace Remover\n+M3Dweller = Spindle start delay\n controller.exception.smoothie.booting = Smoothie has not finished booting.",
            "title": "Localizing"
        },
        {
            "location": "/dev/gcode_processor/#conclusion",
            "text": "We have now fully integrated our  M3Dweller  processor into the UGS framework\nand users of UGS and UGP can both make use of it.  The raw commit for this feature is found on  github here .",
            "title": "Conclusion"
        },
        {
            "location": "/contrib/code/",
            "text": "Code Contributions\n\n\nPull requests are welcome! Is there a feature you would like to see, or a bug\nthats been bothering you? Feel free to dig in. Not sure where to start? Ask on\ngithub, use an existing ticket or create a new one.\n\n\nIf you're planning to make a lot of changes please create an issue to discuss\nimplementation details. A lot of effort has gone into the current design so we\nwant to make sure everything will to work together.",
            "title": "Code"
        },
        {
            "location": "/contrib/code/#code-contributions",
            "text": "Pull requests are welcome! Is there a feature you would like to see, or a bug\nthats been bothering you? Feel free to dig in. Not sure where to start? Ask on\ngithub, use an existing ticket or create a new one.  If you're planning to make a lot of changes please create an issue to discuss\nimplementation details. A lot of effort has gone into the current design so we\nwant to make sure everything will to work together.",
            "title": "Code Contributions"
        },
        {
            "location": "/contrib/docs/",
            "text": "Documentation Contributions\n\n\nThe documentation on this site is written using \nMkDocs\n where the source files are written in \nMarkdown\n.\n\n\nTo contribute follow these steps:\n\n\n\n\n\n\nMake sure you have python installed\n\n\npython --version\n\n\n\n\n\n\n\nInstall MkDocs and the theme \n\n\nsudo pip install mkdocs\nsudo pip install mkdocs-bootswatch\n\n\n\n\n\n\n\nClone the repository \nhttps://github.com/winder/ugs_website\n\n\n\n\n\n\nFrom the cloned root directory run \n\n\nmkdocs serve\n\n\n\n\n\n\n\nGo to \nhttp://localhost:8000/\n in your browser\n\n\n\n\nMake your changes and see them live updating in your web browser",
            "title": "Documentation"
        },
        {
            "location": "/contrib/docs/#documentation-contributions",
            "text": "The documentation on this site is written using  MkDocs  where the source files are written in  Markdown .  To contribute follow these steps:    Make sure you have python installed  python --version    Install MkDocs and the theme   sudo pip install mkdocs\nsudo pip install mkdocs-bootswatch    Clone the repository  https://github.com/winder/ugs_website    From the cloned root directory run   mkdocs serve    Go to  http://localhost:8000/  in your browser   Make your changes and see them live updating in your web browser",
            "title": "Documentation Contributions"
        },
        {
            "location": "/contrib/translation/",
            "text": "Localizing UGS\n\n\nWe are currently using \nPOEditor\n to manage localization.\nIf you would like to help please consider signing up to contribute through this service.\n\n\nTo join the project sign up here: \nhttps://poeditor.com/join/project/2J2hB5I41Z\n\n\nAdding a new language\n\n\nYou can add a new language from POEditor and start translating.\n\n\nIf you want to stop here, create a ticket on GitHub and someone will update the project. To finish the job completely you'll need to know how to use \ngit\n.\n\n\n\n\nCreate an empty property file for your language in \nugs-core/src/resources\n.\n\n\nOpen \nsrc/com/willwinder/universalgcodesender/i18n/AvailableLanguages.java\n\n\nAdd your new translation to the \navailableLanguages\n object.\n\n\nUpdate the file in \nupdate_languages.py\n with a mapping between the POEditor key and your new file.\n\n\nRun \nupdate_languages.py\n, see README in scripts directory for configuration detail. Only commit the new file even if others were updated.\n\n\nCreate a GitHub pull request\n.\n\n\n\n\nFuture language syncs will be done periodically with the \nupdate_languages.py\n script.",
            "title": "Translations"
        },
        {
            "location": "/contrib/translation/#localizing-ugs",
            "text": "We are currently using  POEditor  to manage localization.\nIf you would like to help please consider signing up to contribute through this service.  To join the project sign up here:  https://poeditor.com/join/project/2J2hB5I41Z",
            "title": "Localizing UGS"
        },
        {
            "location": "/contrib/translation/#adding-a-new-language",
            "text": "You can add a new language from POEditor and start translating.  If you want to stop here, create a ticket on GitHub and someone will update the project. To finish the job completely you'll need to know how to use  git .   Create an empty property file for your language in  ugs-core/src/resources .  Open  src/com/willwinder/universalgcodesender/i18n/AvailableLanguages.java  Add your new translation to the  availableLanguages  object.  Update the file in  update_languages.py  with a mapping between the POEditor key and your new file.  Run  update_languages.py , see README in scripts directory for configuration detail. Only commit the new file even if others were updated.  Create a GitHub pull request .   Future language syncs will be done periodically with the  update_languages.py  script.",
            "title": "Adding a new language"
        }
    ]
}